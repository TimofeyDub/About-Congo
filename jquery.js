/*!
 * Библиотека JavaScript jQuery v3.7.1
 * https://jquery.com/
 *
 * Авторские права OpenJS Foundation и других участников.
 * Выпущено под лицензией MIT.
 * https://jquery.org/license.
 *
 * Дата: 28.08.2023T13:37Z
 */
(функция(глобальная, фабрика) {

	«используйте строгий»;

	if ( typeof модуль === "объект" && typeof модуль.exports === "объект" ) {

		// Для CommonJS и CommonJS-подобных сред, где правильное `окно`
		// присутствует, запускаем фабрику и получаем jQuery.
		// Для сред, в которых нет `окна` с `документом`
		// (например, Node.js), выставляем фабрику как модуль.exports.
		// Это подчеркивает необходимость создания настоящего «окна».
		// например, var jQuery = require("jquery")(window);
		// Дополнительную информацию смотрите в билете trac-14549.
		модуль.экспорт = глобальный.документ?
			фабрика (глобальная, правда):
			функция( ш ) {
				если ( !w.document ) {
					throw new Error("jQuery требуется окно с документом");
				}
				вернуть завод( ш );
			};
	} еще {
		фабрика (глобальная);
	}

// Передаем это, если окно еще не определено
} )( typeof window !== "не определено" ? window : this, function( window, noGlobal ) {

// Edge <= 12–13+, Firefox <=18–45+, IE 10–11, Safari 5.1–9+, iOS 6–9.1
// выдаем исключения, когда нестрогий код (например, ASP.NET 4.5) обращается к строгому режиму
// аргументы.callee.caller (trac-13335). Но начиная с jQuery 3.0 (2016) строгий режим должен быть обычным явлением.
// достаточно, чтобы все такие попытки были защищены блоком try.
«используйте строгий»;

вар обр = [];

вар getProto = Object.getPrototypeOf;

вар срез = arr.slice;

вар квартира = аранж.квартира? функция (массив) {
	вернуть arr. Flat.call (массив);
} : функция(массив) {
	вернуть arr.concat.apply([], массив);
};


вар push = arr.push;

вар indexOf = arr.indexOf;

вар class2type = {};

вар toString = class2type.toString;

вар hasOwn = class2type.hasOwnProperty;

вар fnToString = hasOwn.toString;

вар ObjectFunctionString = fnToString.call(Объект);

поддержка вар = {};

вар isFunction = функция isFunction(obj) {

		// Поддержка: Chrome <=57, Firefox <=52
		// В некоторых браузерах typeof возвращает «функцию» для элементов HTML <object>
		// (т.е. `typeof document.createElement( "object" ) === "function"`).
		// Мы не хотим классифицировать *любой* узел DOM как функцию.
		// Поддержка: QtWeb <=3.8.5, WebKit <=534.34, инструмент wkhtmltopdf <=0.12.5
		// Плюс для старого WebKit, typeof возвращает «функцию» для коллекций HTML
		// (например, `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "функция" && typeof obj.nodeType !== "число" &&
			typeof obj.item !== "функция";
	};


вар isWindow = функция isWindow(obj) {
		return obj != null && obj === obj.window;
	};


вар документ = window.document;



	вар сохранённыйScriptAttributes = {
		тип: правда,
		источник: правда,
		одноразовый номер: правда,
		нетМодуль: правда
	};

	функция DOMEval(код, узел, документ) {
		документ = документ || документ;

		вар я, вал,
			скрипт = doc.createElement("скрипт");

		скрипт.текст = код;
		если (узел) {
			for (я в сохраненныхScriptAttributes) {

				// Поддержка: Firefox 64+, Edge 18+
				// Некоторые браузеры не поддерживают свойство nonce в скриптах.
				// С другой стороны, просто использовать `getAttribute` недостаточно, поскольку
				// атрибут nonce сбрасывается в пустую строку всякий раз, когда он
				// становится подключенным к контексту просмотра.
				// См. https://github.com/whatwg/html/issues/2369.
				// См. https://html.spec.whatwg.org/#nonce-attributes.
				// Проверка `node.getAttribute` была добавлена ​​ради
				// `jQuery.globalEval`, чтобы он мог подделать узел, содержащий nonce
				// через объект.
				вал = узел [ я ] || node.getAttribute && node.getAttribute(i);
				если (значение) {
					script.setAttribute(я, значение);
				}
			}
		}
		doc.head.appendChild(скрипт).parentNode.removeChild(скрипт);
	}


функция toType(объект) {
	если (объект == ноль) {
		вернуть объект + "";
	}

	// Поддержка: только Android <= 2.3 (функция RegExp)
	return typeof obj === "объект" || typeof obj === "функция"?
		class2type[ toString.call(obj) ] || "объект" :
		тип объекта;
}
/* глобальный символ */
// Определение этого глобального в .eslintrc.json создаст опасность использования глобального
// неохраняемый в другом месте, кажется безопаснее определить global только для этого модуля



вар версия = "3.7.1",

	rhtmlСуффикс = /HTML$/i,

	// Определить локальную копию jQuery
	jQuery = функция (селектор, контекст) {

		// Объект jQuery на самом деле является просто «улучшенным» конструктором инициализации
		// Требуется инициализация, если вызывается jQuery (просто разрешите выдачу ошибки, если она не включена)
		вернуть новый jQuery.fn.init(селектор, контекст);
	};

jQuery.fn = jQuery.prototype = {

	// Используемая текущая версия jQuery
	jquery: версия,

	конструктор: jQuery,

	// Длина объекта jQuery по умолчанию равна 0
	длина: 0,

	toArray: функция() {
		вернуть срез.call(это);
	},

	// Получаем N-й элемент в наборе совпадающих элементов ИЛИ
	// Получаем весь набор совпадающих элементов в виде чистого массива
	получить: функция (число) {

		// Возвращаем все элементы чистого массива
		если (число == ноль) {
			вернуть срез.call(это);
		}

		// Возвращаем только один элемент из набора
		вернуть число <0? это[число + эта.длина]: это[число];
	},

	// Берем массив элементов и помещаем его в стек
	// (возвращаем новый набор совпавших элементов)
	pushStack: функция (элементы) {

		// Создаем новый набор элементов, соответствующий jQuery
		var ret = jQuery.merge(this.constructor(), elems);

		// Добавляем старый объект в стек (в качестве ссылки)
		ret.prevObject = это;

		// Возвращаем вновь сформированный набор элементов
		вернуть возврат;
	},

	// Выполняем обратный вызов для каждого элемента в сопоставленном наборе.
	каждый: функция (обратный вызов) {
		вернуть jQuery.each(это, обратный вызов);
	},

	карта: функция (обратный вызов) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			вернуть обратный вызов.вызов(элем, я, элем);
		} ) );
	},

	срез: функция() {
		return this.pushStack(slice.apply(this, аргументы));
	},

	сначала: функция() {
		вернуть this.eq(0);
	},

	последнее: функция() {
		вернуть this.eq(-1);
	},

	даже: функция() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			возврат (я + 1) % 2;
		} ) );
	},

	нечетно: функция() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			вернуть я% 2;
		} ) );
	},

	уравнение: функция( я ) {
		вар лен = this.length,
			j = +i + (я <0 ? len: 0);
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	конец: функция() {
		вернуть this.prevObject || этот.конструктор();
	},

	// Только для внутреннего использования.
	// Ведёт себя как метод Array, а не как метод jQuery.
	двутолчковый,
	сортировка: сортировка,
	сращивание: аранж.сращивание
};

jQuery.extend = jQuery.fn.extend = function() {
	параметры var, имя, источник, копия, copyIsArray, клон,
		цель = аргументы[0] || {},
		я = 1,
		длина = аргументы.длина,
		глубокий = ложь;

	// Обработка ситуации глубокого копирования
	if ( typeof target === "boolean" ) {
		глубокий = цель;

		// Пропускаем логическое значение и цель
		цель = аргументы[ я ] || {};
		я++;
	}

	// Обработка случая, когда целью является строка или что-то в этом роде (возможно при глубоком копировании)
	if ( typeof target !== "object" && !isFunction(target)) {
		цель = {};
	}

	// Расширяем сам jQuery, если передается только один аргумент
	если ( я === длина ) {
		цель = это;
		я--;
	}

	для ( ; я < длина; я++ ) {

		// Работаем только с ненулевыми/неопределенными значениями
		if ( ( options = аргументы [ i ] ) != null ) {

			// Расширяем базовый объект
			for (имя в настройках) {
				копировать = параметры [имя];

				// Предотвратить загрязнение Object.prototype
				// Предотвращаем бесконечный цикл
				if (имя === "__proto__" || цель === копия) {
					продолжать;
				}

				// Рекурсия, если мы объединяем простые объекты или массивы
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray(копия) ) ) ) {
					источник = цель [имя];

					// Обеспечиваем правильный тип исходного значения
					if ( copyIsArray && !Array.isArray(src) ) {
						клон = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject(src) ) {
						клон = {};
					} еще {
						клон = источник;
					}
					copyIsArray = ложь;

					// Никогда не перемещайте исходные объекты, клонируйте их
					цель [имя] = jQuery.extend(глубокий, клон, копия);

				// Не вводите неопределенные значения
				} еще если (копия!== не определено) {
					цель [имя] = копия;
				}
			}
		}
	}

	// Возвращаем измененный объект
	возвратная цель;
};

jQuery.extend( {

	// Уникально для каждой копии jQuery на странице
	развернуть: "jQuery" + (версия + Math.random()).replace( /\D/g, "" ),

	// Предположим, что jQuery готов без готового модуля
	isReady: правда,

	ошибка: функция (сообщение) {
		выдать новую ошибку (сообщение);
	},

	нуп: функция() {},

	isPlainObject: функция (объект) {
		вар прото, Тор;

		// Обнаружение очевидных негативов
		// Используйте toString вместо jQuery.type для перехвата объектов хоста
		if ( !obj || toString.call(obj) !== "[object Object]" ) {
			вернуть ложь;
		}

		прото = getProto(объект);

		// Объекты без прототипа (например, `Object.create(null)`) являются простыми
		если ( !прото ) {
			вернуть истину;
		}

		// Объекты с прототипом являются простыми, если они были созданы глобальной функцией объекта.
		Ctor = hasOwn.call(прото, «конструктор») && proto.constructor;
		return typeof Ctor === "функция" && fnToString.call( Ctor) === ObjectFunctionString;
	},

	isEmptyObject: функция (объект) {
		имя переменной;

		for (имя в объекте) {
			вернуть ложь;
		}
		вернуть истину;
	},

	// Оценивает скрипт в предоставленном контексте; возвращается к глобальному
	// если не указано.
	globalEval: функция (код, параметры, документ) {
		DOMEval(код, { nonce: options && options.nonce }, doc );
	},

	каждый: функция (объект, обратный вызов) {
		длина переменной, я = 0;

		если ( isArrayLike(obj ) ) {
			длина = объект.длина;
			для ( ; я < длина; я++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					перерыв;
				}
			}
		} еще {
			для (я в объекте) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					перерыв;
				}
			}
		}

		вернуть объект;
	},


	// Получаем текстовое значение массива узлов DOM
	текст: функция (элемент) {
		вар узел,
			Рет = "",
			я = 0,
			тип узла = элемент.тип узла;

		если (!nodeType) {

			// Если нет nodeType, ожидается, что это будет массив
			while ( ( node = elem[ i++ ] ) ) {

				// Не пересекать узлы комментариев
				ret += jQuery.text(узел);
			}
		}
		if (nodeType === 1 || nodeType === 11) {
			вернуть элемент.textContent;
		}
		если (тип узла === 9) {
			вернуть элемент.documentElement.textContent;
		}
		if (nodeType === 3 || nodeType === 4) {
			вернуть элемент.nodeValue;
		}

		// Не включайте узлы комментариев или инструкций обработки

		вернуть возврат;
	},

	// результаты предназначены только для внутреннего использования
	makeArray: функция (прибытие, результаты) {
		вар ret = результаты || [];

		если (прибытие!= ноль) {
			если ( isArrayLike ( Object ( arr ) ) ) {
				jQuery.merge(рет,
					typeof arr === "строка" ?
						[приб.]: приб.
				);
			} еще {
				push.call(рет, прибытие);
			}
		}

		вернуть возврат;
	},

	inArray: функция (elem, arr, i) {
		вернуть arr == ноль? -1: indexOf.call(arr, elem, i);
	},

	isXMLDoc: функция (элемент) {
		var namespace = elem && elem.namespaceURI,
			docElem = элемент && (elem.ownerDocument || elem).documentElement;

		// Предполагаем HTML, когда documentElement еще не существует, например внутри
		// фрагменты документа.
		return !rhtmlSuffix.test( пространство имен || docElem && docElem.nodeName || "HTML" );
	},

	// Поддержка: только Android <= 4.0, только PhantomJS 1
	// push.apply(_, arraylike) вызывает древний WebKit
	слияние: функция (первая, вторая) {
		вар лен = +секунда.длина,
			j = 0,
			я = первая.длина;

		for ( ; j < len; j++ ) {
			первый [ я++ ] = второй [ j ];
		}

		first.length = я;

		вернуться первым;
	},

	grep: функция (элементы, обратный вызов, инвертирование) {
		вар callbackInverse,
			совпадения = [],
			я = 0,
			длина = элементы.длина,
			callbackExpect = !invert;

		// Проходимся по массиву, сохраняя только элементы
		// которые передают функцию валидатора
		для ( ; я < длина; я++ ) {
			callbackInverse = !callback(elems[i], i);
			if ( callbackInverse !== callbackExpect ) {
				match.push(elems[i]);
			}
		}

		ответные матчи;
	},

	// arg предназначен только для внутреннего использования
	карта: функция (элементы, обратный вызов, arg) {
		длина переменной, значение,
			я = 0,
			Рет = [];

		// Проходим по массиву, переводя каждый из элементов в новые значения
		если ( isArrayLike ( элементы ) ) {
			длина = элементы.длина;
			для ( ; я < длина; я++ ) {
				значение = обратный вызов (elems[i], i, arg);

				если (значение! = ноль) {
					ret.push(значение);
				}
			}

		// Проходим каждый ключ объекта,
		} еще {
			for (я в элементах) {
				значение = обратный вызов (elems[i], i, arg);

				если (значение! = ноль) {
					ret.push(значение);
				}
			}
		}

		// Сглаживание любых вложенных массивов
		вернуть квартиру( в аренду );
	},

	// Глобальный счетчик GUID для объектов
	руководство: 1,

	// jQuery.support не используется в Core, но другие проекты добавляют свои
	// свойства, поэтому он должен существовать.
	поддержка: поддержка
});

if ( typeof Символ === "функция" ) {
	jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
}

// Заполняем карту class2type
jQuery.each( "Логическое число Строка Функция Массив Дата Символ ошибки объекта RegExp".split( " " ),
	функция( _i, имя) {
		class2type[ "[объект " + имя + "]" ] = name.toLowerCase();
	});

функция isArrayLike(объект) {

	// Поддержка: только настоящая iOS 8.2 (не воспроизводится в симуляторе)
	// проверка `in`, используемая для предотвращения ошибки JIT (gh-2145)
	// hasOwn здесь не используется из-за ложноотрицательных результатов
	// относительно длины списка узлов в IE
	var length = !!obj && "длина" в obj && obj.length,
		тип = toType(объект);

	если ( isFunction(obj) || isWindow(obj) ) {
		вернуть ложь;
	}

	тип возвращаемого значения === "массив" || длина === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) в obj;
}


функция nodeName( элемент, имя ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
вар поп = arr.pop;


вар сортировка = arr.sort;


вар сплайс = arr.splice;


var пробел = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = новый RegExp(
	"^" + пробел + "+|((?:^|[^\\\\])(?:\\\\.)*)" + пробел + "+$",
	"г"
);




// Примечание: элемент не содержит самого себя
jQuery.contains = функция( а, б ) {
	var bup = b && b.parentNode;

	вернуть === bup || !!( bup && bup.nodeType === 1 && (

		// Поддержка: IE 9–11+
		// IE не содержит `contains` в SVG.
		а.содержит?
			a.contains(буп):
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// Сериализация CSS-строки/идентификатора
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

функция fcssescape(ch, asCodePoint) {
	если ( asCodePoint ) {

		// U+0000 NULL становится ЗАМЕНЯЮЩИМ СИМВОЛОМ U+FFFD
		если ( ч === "\0" ) {
			вернуть "\uFFFD";
		}

		// Управляющие символы и (в зависимости от позиции) числа экранируются как кодовые точки
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Другие потенциально специальные символы ASCII экранируются обратной косой чертой
	вернуть "\\" + ч;
}

jQuery.escapeSelector = функция (сел) {
	return (sel + "").replace(rcssescape, fcssescape);
};




вар PreferredDoc = документ,
	pushNative = нажать;

(функция() {

вар я,
	выражение,
	внешнийконтекст,
	сортировкаВвод,
	имеет дубликат,
	нажать = pushNative,

	// Переменные локального документа
	документ,
	документЭлемент,
	документIsHTML,
	рбаггиQSA,
	Матчи,

	// Данные, специфичные для экземпляра
	развернуть = jQuery.expando,
	дирруны = 0,
	сделано = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	нероднойSelectorCache = createCache(),
	sortOrder = функция( а, б ) {
		если ( а === б ) {
			имеетДупликат = Истина;
		}
		вернуть 0;
	},

	booleans = "проверено|выбрано|асинхронно|автофокус|автовоспроизведение|управление|отложить|отключено|скрыто|ismap|" +
		"цикл|множественный|открытый|только для чтения|обязательный|с ограниченной областью”,

	// Обычные выражения

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	идентификатор = "(?:\\\\[\\da-fA-F]{1,6}" + пробел +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Селекторы атрибутов: https://www.w3.org/TR/selectors/#attribute-selectors
	атрибуты = "\\[" + пробел + "*(" + идентификатор + ")(?:" + пробел +

		// Оператор (захват 2)
		"*([*^$|!~]?=)" + пробел +

		// "Значения атрибутов должны быть идентификаторами CSS [capture 5] или строками [capture 3 или capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"] )*)\"|(" + идентификатор + "))|)" +
		пробел + "*\\]",

	pseudos = ":(" + идентификатор + ")(?:\\((" +

		// Чтобы уменьшить количество селекторов, нуждающихся в токенизации в preFilter, отдайте предпочтение аргументам:
		// 1. в кавычках (захват 3; захват 4 или захват 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*) \"")|" +

		// 2. простой (захват 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + атрибуты + ")*)|" +

		// 3. что-нибудь еще (захват 2)
		".*" +
		")\\)|)",

	// Ведущие и неэкранированные конечные пробелы, захват некоторых непробельных символов, предшествующих последнему
	rwhitespace = новый RegExp(пробел + "+", "g" ),

	rcomma = new RegExp( "^" + пробел + "*," + пробел + "*" ),
	rleadingCombinator = new RegExp( "^" + пробел + "*([>+~]|" + пробел + ")" +
		пробел + "*"),
	rdescend = новый RegExp(пробел + "|>" ),

	rpseudo = новый RegExp(псевдо),
	Ridentifier = новый RegExp( "^" + идентификатор + "$" ),

	matchExpr = {
		Идентификатор: новый RegExp( "^#(" + идентификатор + ")" ),
		КЛАСС: новый RegExp( "^\\.(" + идентификатор + ")" ),
		ТЕГ: новый RegExp( "^(" + идентификатор + "|[*])" ),
		ATTR: новый RegExp( "^" + атрибуты),
		ПСЕВДО: новый RegExp( "^" + псевдонимы),
		РЕБЕНОК: новое RegExp(
			"^:(только|первый|последний|n-й|n-й-последний)-(дочерний|типа)(?:\\(" +
				пробел + "*(четный|нечетный|(([+-]|)(\\d*)n|)" + пробел + "*(?:([+-]|)" +
				пробел + "*(\\d+)|))" + пробел + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + логические значения + ")$", "i" ),

		// Для использования в библиотеках, реализующих .is()
		// Мы используем это для сопоставления POS в `select`
		NeedContext: новый RegExp( "^" + пробел +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + пробел +
			"*((?:-\\d)?\\d*)" + пробел + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	заголовок = /^h\d$/i,

	// Легко анализируемые/извлекаемые селекторы ID, TAG или CLASS
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS экранирует
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + пробел +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = функция (побег, нешестнадцатеричный) {
		var high = "0x" + escape.slice(1) - 0x10000;

		если (нешестнадцатеричный) {

			// Удаляем префикс обратной косой черты из нешестнадцатеричной escape-последовательности
			вернуть неHex;
		}

		// Заменяем шестнадцатеричную escape-последовательность закодированной кодовой точкой Unicode
		// Поддержка: IE <=11+
		// Для значений за пределами базовой многоязычной плоскости (BMP) вручную создаем
		// суррогатная пара
		вернуть высокий <0?
			String.fromCharCode(высокий + 0x10000):
			String.fromCharCode(высокое >> 10 | 0xD800, высокое & 0x3FF | 0xDC00);
	},

	// Используется для iframe; см. `setDocument`.
	// Поддержка: IE 9–11+, Edge 12–18+
	// Удаление оболочки функции приводит к отказу в разрешении
	// ошибка в IE/Edge.
	unloadHandler = функция() {
		УстановитьДокумент();
	},

	inDisabledFieldset = addCombinator(
		функция( элемент ) {
			return elem.disabled === true && nodeName(elem, "fieldset");
		},
		{ каталог: "parentNode", следующий: "легенда" }
	);

// Поддержка: только IE <=9
// Доступ к document.activeElement может неожиданно вызвать ошибку
// https://bugs.jquery.com/ticket/13393
функция SafeActiveElement() {
	пытаться {
		вернуть документ.активныйЭлемент;
	} поймать (ошибиться) { }
}

// Оптимизация для push.apply( _, NodeList )
пытаться {
	push.apply(
		(arr = срез.вызов(предпочтительныйDoc.childNodes)),
		предпочтительныйDoc.childNodes
	);

	// Поддержка: Android <= 4.0
	// Обнаруживаем молчаливый сбой push.apply
	// eslint-disable-next-line без неиспользуемых-выражений
	arr[preferredDoc.childNodes.length].nodeType;
} поймать ( е ) {
	нажать = {
		применить: функция (цель, элс) {
			pushNative.apply(цель, срез.call(элс));
		},
		вызов: функция (цель) {
			pushNative.apply(цель, срез.вызов(аргументы, 1));
		}
	};
}

функция find(селектор, контекст, результаты, начальное число) {
	var m, i, elem, nid, match, groups, newSelector,
		новыйКонтекст = контекст && context.ownerDocument,

		// nodeType по умолчанию равен 9, поскольку контекст по умолчанию равен document
		Тип узла = контекст? context.nodeType: 9;

	результаты = результаты || [];

	// Досрочный возврат из вызовов с неверным селектором или контекстом
	if ( селектор typeof !== "строка" || !селектор ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		возврат результатов;
	}

	// Попробуйте сократить операции поиска (в отличие от фильтров) в HTML-документах
	если ( !семя ) {
		УстановитьДокумент (контекст);
		контекст = контекст || документ;

		если (документIsHTML) {

			// Если селектор достаточно прост, попробуйте использовать DOM-метод "get*By*"
			// (за исключением контекста DocumentFragment, где методы не существуют)
			if ( nodeType !== 11 && ( match = rquickExpr.exec ( селектор )) ) {

				// селектор идентификатора
				если ( ( м = совпадение [ 1 ] ) ) {

					// Контекст документа
					если (тип узла === 9) {
						если ( ( elem = context.getElementById( m ) ) ) {

							// Поддержка: только IE 9
							// getElementById может сопоставлять элементы по имени, а не по идентификатору
							если ( elem.id === м ) {
								push.call(результаты, элемент);
								возврат результатов;
							}
						} еще {
							возврат результатов;
						}

					// Контекст элемента
					} еще {

						// Поддержка: только IE 9
						// getElementById может сопоставлять элементы по имени, а не по идентификатору
						if (newContext && (elem = newContext.getElementById(m)) &&
							find.contains(контекст, элемент) &&
							elem.id === м ) {

							push.call(результаты, элемент);
							возврат результатов;
						}
					}

				// Селектор типа
				} иначе если ( match[ 2 ] ) {
					push.apply(результаты, context.getElementsByTagName(селектор));
					возврат результатов;

				// Селектор класса
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply(результаты, context.getElementsByClassName(m));
					возврат результатов;
				}
			}

			// Воспользуйтесь преимуществами querySelectorAll
			if ( !nonnativeSelectorCache[ селектор + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test(селектор) )) {

				новыйСелектор = селектор;
				новыйКонтекст = контекст;

				// qSA учитывает элементы вне корня области видимости при оценке дочернего или
				// комбинаторы-потомки, а это не то, что нам нужно.
				// В таких случаях мы обходим это поведение, добавляя префикс к каждому селектору в
				// список с селектором идентификатора, ссылающимся на контекст области.
				// Этот метод необходимо использовать и при использовании ведущего комбинатора
				// поскольку такие селекторы не распознаются querySelectorAll.
				// Спасибо Эндрю Дюпону за эту технику.
				если (тип узла === 1 &&
					( rdescend.test(селектор) || rleadingCombinator.test(селектор) ) ) {

					// Расширяем контекст для одноуровневых селекторов
					newContext = rsibling.test(селектор) && testContext(context.parentNode) ||
						контекст;

					// Мы можем использовать :scope вместо взлома идентификатора, если браузер
					// поддерживает это, и если мы не меняем контекст.
					// Поддержка: IE 11+, Edge 17–18+
					// IE/Edge иногда выдает ошибку «Отказано в разрешении», когда
					// строгое сравнение двух документов; поверхностные сравнения работают.
					// eslint-disable-next-line eqeqeq
					if (newContext!= context || !support.scope) {

						// Захватываем идентификатор контекста, при необходимости сначала устанавливая его
						если ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector(nid);
						} еще {
							context.setAttribute("id", (nid =expando));
						}
					}

					// Префикс каждого селектора в списке
					группы = tokenize(селектор);
					я = группы.длина;
					в то время как я-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope") + " " +
							toSelector(группы[я]);
					}
					newSelector = groups.join( ",");
				}

				пытаться {
					push.apply(результаты,
						newContext.querySelectorAll(newSelector)
					);
					возврат результатов;
				} поймать (qsaError) {
					NonnativeSelectorCache (селектор, правда);
				} окончательно {
					если (нид === экспандо) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// Все другие
	return select( selector.replace( rtrimCSS, "$1" ), контекст, результаты, начальное число );
}

/**
 * Создавайте кэши значений ключа ограниченного размера.
 * @returns {function(string, object)} Возвращает данные объекта после их сохранения с помощью
 * имя свойства — строка (с суффиксом пробела) и (если кэш больше, чем Expr.cacheLength)
 * удаление самой старой записи
 */
функция createCache() {
	вар ключи = [];

	кэш функции(ключ, значение) {

		// Используйте (ключ + " "), чтобы избежать столкновения с собственными свойствами прототипа
		// (см. https://github.com/jquery/sizzle/issues/157)
		if (keys.push(key + " ") > Expr.cacheLength) {

			// Сохраняем только самые последние записи
			удалить кэш [keys.shift()];
		}
		return (кэш[ключ + ""] = значение);
	}
	возврат кэша;
}

/**
 * Отметьте функцию для специального использования модулем выбора jQuery.
 * @param {Function} fn Функция для отметки
 */
функция markFunction( fn ) {
	fn[expando] = правда;
	вернуть ФН;
}

/**
 * Поддержка тестирования с использованием элемента
 * @param {Function} fn Передает созданный элемент и возвращает логический результат
 */
функция утверждения( fn ) {
	var el = document.createElement("набор полей");

	пытаться {
		вернуть !!fn(эль);
	} поймать ( е ) {
		вернуть ложь;
	} окончательно {

		// Удаляем из родителя по умолчанию
		если ( el.parentNode ) {
			el.parentNode.removeChild(эль);
		}

		// освобождаем память в IE
		эл = ноль;
	}
}

/**
 * Возвращает функцию для использования в псевдо-типах ввода.
 * Тип @param {String}
 */
функция createInputPseudo(тип) {
	функция возврата (элемент) {
		return nodeName(elem, "input") && elem.type === type;
	};
}

/**
 * Возвращает функцию для использования в псевдо-кнопках.
 * Тип @param {String}
 */
функция createButtonPseudo(тип) {
	функция возврата (элемент) {
		return (nodeName(elem, "input") || nodeName(elem, "button" ) ) &&
			элемент.тип === тип;
	};
}

/**
 * Возвращает функцию для использования в псевдонимах для :enabled/:disabled
 * @param {Boolean} отключено true для :disabled; ложь для: включено
 */
функция createDisabledPseudo (отключена) {

	// Известные :отключено ложные срабатывания: fieldset[disabled] > легенда:nth-of-type(n+2) :can-disable
	функция возврата (элемент) {

		// Только определенные элементы могут соответствовать :enabled или :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if («форма» в элементе) {

			// Проверка унаследованной отключенности соответствующих неотключенных элементов:
			// * перечислены элементы, связанные с формой, в отключенном наборе полей
			// https://html.spec.whatwg.org/multipage/forms.html#category-listed
			// https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * элементы опций в отключенной группе опций
			// https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// Все такие элементы имеют свойство form.
			if ( elem.parentNode && elem.disabled === false ) {

				// Элементы опций подчиняются родительской группе опций, если она присутствует
				if («метка» в элементе) {
					if («метка» в elem.parentNode) {
						return elem.parentNode.disabled === отключено;
					} еще {
						return elem.disabled === отключено;
					}
				}

				// Поддержка: IE 6–11+
				// Используйте свойство ярлыка isDisabled для проверки отключенных предков набора полей
				return elem.isDisabled === отключено ||

					// Там, где нет isDisabled, проверяем вручную
					elem.isDisabled !== !disabled &&
						inDisabledFieldset(elem) === отключено;
			}

			return elem.disabled === отключено;

		// Попытайтесь отсеять элементы, которые невозможно отключить, прежде чем доверять отключенному свойству.
		// Некоторые жертвы попадают в нашу сеть (метка, легенда, меню, трек), но это не должно
		// даже существуют на них, не говоря уже о том, чтобы иметь логическое значение.
		} else if («метка» в элементе) {
			return elem.disabled === отключено;
		}

		// Остальные элементы не :включены и не :отключены
		вернуть ложь;
	};
}

/**
 * Возвращает функцию для использования в псевдонимах для позиционных чисел.
 * @param {Функция} fn
 */
функция createPositionalPseudo(fn) {
	вернуть markFunction(функция(аргумент) {
		аргумент = +аргумент;
		return markFunction(функция(семя, совпадения) {
			вар Дж,
				matchIndexes = fn( [], семя.длина, аргумент),
				я = matchIndexes.length;

			// Сопоставление элементов, найденных по указанным индексам
			в то время как я-- ) {
				if (seed[ ( j = matchIndexes[ i ] ) ] ) {
					семя[ j ] = !( совпадения[ j ] = семя [ j ] );
				}
			}
		});
	});
}

/**
 * Проверяет узел на достоверность в качестве контекста селектора jQuery.
 * контекст @param {Element|Object=}
 * @returns {Element|Object|Boolean} Входной узел, если он приемлем, в противном случае — ложное значение.
 */
функция testContext(контекст) {
	возвращаемый контекст && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Устанавливает переменные, связанные с документом, один раз на основе текущего документа.
 * @param {Element|Object} [node] Элемент или объект документа, используемый для установки документа.
 * @returns {Object} Возвращает текущий документ
 */
функция setDocument(узел) {
	вар подокно,
		документ = узел? node.ownerDocument || узел: предпочтительныйДок;

	// Возврат досрочно, если документ недействителен или уже выбран
	// Поддержка: IE 11+, Edge 17–18+
	// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
	// два документа; поверхностные сравнения работают.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		возвратный документ;
	}

	// Обновляем глобальные переменные
	документ = документ;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc(документ);

	// Поддержка: только iOS 7, IE 9–11+
	// Старые браузеры не поддерживали `совпадения` без префиксов.
	совпадения = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Поддержка: IE 9–11+, Edge 12–18+
	// Доступ к документам iframe после выгрузки вызывает ошибки «отказано в разрешении»
	// (см. trac-13936).
	// Ограничьте исправление IE и Edge Legacy; несмотря на то, что Edge 15+ реализует `совпадения`,
	// все версии IE 9+ и Edge Legacy также реализуют `msMatchesSelector`.
	если ( documentElement.msMatchesSelector &&

		// Поддержка: IE 11+, Edge 17–18+
		// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
		// два документа; поверхностные сравнения работают.
		// eslint-disable-next-line eqeqeq
		предпочтительныйДок != документ &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Поддержка: IE 9–11+, Edge 12–18+
		subWindow.addEventListener("выгрузить", unloadHandler);
	}

	// Поддержка: IE <10
	// Проверяем, возвращает ли getElementById элементы по имени
	// Неработающие методы getElementById не получают имена, заданные программно,
	// поэтому используйте обходной тест getElementsByName
	support.getById = утверждать (функция (эл) {
		documentElement.appendChild(el).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName(jQuery.expando).length;
	});

	// Поддержка: только IE 9
	// Проверяем, возможно ли выполнить matchSelector
	// на отключенном узле.
	support.disconnectedMatch = утверждать (функция (эл) {
		вернуть match.call(el, "*" );
	});

	// Поддержка: IE 9–11+, Edge 12–18+
	// IE/Edge не поддерживает псевдокласс :scope.
	support.scope = утверждать(функция() {
		return document.querySelectorAll(":scope");
	});

	// Поддержка: только Chrome 105–111, только Safari 15.4–16.3
	// Убедитесь, что аргумент `:has()` анализируется беспощадно.
	// Мы включаем `*` в тест, чтобы обнаружить ошибочные реализации, которые
	// _выборочно_ прощающий (особенно когда список включает хотя бы
	// один действительный селектор).
	// Обратите внимание, что мы рассматриваем полное отсутствие поддержки `:has()`, как если бы это было
	// поддержка, соответствующая спецификации, и это нормально, поскольку использование `:has()` в таких
	// среды потерпят неудачу на пути qSA и вернутся к обходу jQuery
	// в любом случае.
	support.cssHas = утверждать(функция() {
		пытаться {
			document.querySelector( ":has(*,:jqfake)" );
			вернуть ложь;
		} поймать ( е ) {
			вернуть истину;
		}
	});

	// Фильтруем идентификатор и находим
	если (support.getById) {
		Выраж.фильтр.ИД = функция(идентификатор) {
			var attrId = id.replace(runescape, funescape);
			функция возврата (элемент) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Выражение.найти.ИД = функция(идентификатор, контекст) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById(id);
				вернуть элемент? [ элем ] : [];
			}
		};
	} еще {
		Выраж.фильтр.ИД = функция(идентификатор) {
			var attrId = id.replace(runescape, funescape);
			функция возврата (элемент) {
				var node = typeof elem.getAttributeNode !== "не определено" &&
					elem.getAttributeNode("id");
				вернуть узел && node.value === attrId;
			};
		};

		// Поддержка: только IE 6–7
		// getElementById ненадежен в качестве ярлыка для поиска
		Выражение.найти.ИД = функция(идентификатор, контекст) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				вар узел, я, элементы,
					элемент = context.getElementById(id);

				если ( элем ) {

					// Проверяем атрибут id
					node = elem.getAttributeNode("id");
					if (узел && node.value === id) {
						вернуть [элемент];
					}

					// Возвращаемся к getElementsByName
					элементы = context.getElementsByName(id);
					я = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode("id");
						if (узел && node.value === id) {
							вернуть [элемент];
						}
					}
				}

				возвращаться [];
			}
		};
	}

	// Ярлык
	Выражение.найти.TAG = функция(тег, контекст) {
		if ( typeof context.getElementsByTagName !== "не определено" ) {
			вернуть context.getElementsByTagName(тег);

		// Узлы DocumentFragment не имеют gEBTN
		} еще {
			вернуть context.querySelectorAll(тег);
		}
	};

	// Сорт
	Выражение.найти.КЛАСС = функция(Имя класса, контекст) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName(имякласса);
		}
	};

	/* QSA/matchesSelector
	-------------------------------------------------- -------------------- */

	// Поддержка QSA и matchSelector

	rbuggyQSA = [];

	// Создаем регулярное выражение QSA
	// Стратегия регулярных выражений, заимствованная у Диего Перини
	утверждать (функция (эл) {

		ввод вар;

		documentElement.appendChild(el).innerHTML =
			"<a id='" +expando + "' href=''disabled='disabled'></a>" +
			"<select id='" +expando + "-\r\\'disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Поддержка: только iOS <= 7–8
		// Логические атрибуты и «значение» неправильно обрабатываются в некоторых XML-документах.
		if ( !el.querySelectorAll("[выбрано]").length) {
			rbuggyQSA.push( "\\[" + пробел + "*(?:value|" + логические значения + ")" );
		}

		// Поддержка: только iOS <= 7–8
		if ( !el.querySelectorAll( "[id~=" +expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Поддержка: только iOS 8
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// Внутристраничный `селектор #id sibling-combinator` не работает
		if ( !el.querySelectorAll( "a#" +expando + "+*").length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Поддержка: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// В некоторых типах документов эти селекторы изначально не работают.
		// Вероятно, это нормально, но для обратной совместимости мы хотим сохранить
		// обработка их посредством обхода jQuery в jQuery 3.x.
		if ( !el.querySelectorAll(":checked").length ) {
			rbuggyQSA.push(":проверено");
		}

		// Поддержка: собственные приложения для Windows 8
		// Атрибуты type и name ограничены во время назначения .innerHTML
		input = document.createElement("вход");
		input.setAttribute("тип", "скрытый");
		el.appendChild(input).setAttribute("имя", "D");

		// Поддержка: IE 9–11+
		// Селектор :disabled в IE не выбирает дочерние элементы отключенных наборов полей
		// Поддержка: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// В некоторых типах документов эти селекторы изначально не работают.
		// Вероятно, это нормально, но для обратной совместимости мы хотим сохранить
		// обработка их посредством обхода jQuery в jQuery 3.x.
		documentElement.appendChild(el).disabled = true;
		if ( el.querySelectorAll( ":disabled").length !== 2 ) {
			rbuggyQSA.push( ":включено", ":отключено" );
		}

		// Поддержка: IE 11+, Edge 15–18+
		// IE 11/Edge в некоторых случаях не находит элементы по запросу `[name='']`.
		// Добавляем временный атрибут в документ до того, как сработает выделение
		// вокруг проблемы.
		// Интересно, что в IE 10 и старше этой проблемы, похоже, нет.
		input = document.createElement("вход");
		input.setAttribute("имя", "");
		el.appendChild(вход);
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + пробел + "*имя" + пробел + "*=" +
				пробел + "*(?:''|\"\")" );
		}
	});

	если (!support.cssHas) {

		// Поддержка: Chrome 105–110+, Safari 15,4–16,3+
		// Наш обычный механизм try-catch не может обнаружить изначально неподдерживаемые
		// псевдоклассы внутри `:has()` (например, `:has(:contains("Foo"))`)
		// в браузерах, которые анализируют аргумент `:has()` как список прощающих селекторов.
		// https://drafts.csswg.org/selectors/#relational теперь требует аргумент
		// будет беспощадно анализироваться, но браузеры еще не полностью адаптированы.
		rbuggyQSA.push(":has");
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Сортировка
	-------------------------------------------------- -------------------- */

	// Сортировка порядка документов
	sortOrder = функция( а, б ) {

		// Флаг удаления дубликатов
		если ( а === б ) {
			имеетДупликат = Истина;
			вернуть 0;
		}

		// Сортировка по существованию метода, если только один вход имеет CompareDocumentPosition
		var Compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		если ( сравнить ) {
			возврат сравнения;
		}

		// Вычисляем позицию, если оба входа принадлежат одному и тому же документу
		// Поддержка: IE 11+, Edge 17–18+
		// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
		// два документа; поверхностные сравнения работают.
		// eslint-disable-next-line eqeqeq
		сравнить = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition(б):

			// В противном случае мы знаем, что они отключены
			1;

		// Отключенные узлы
		если (сравнить & 1 ||
			( !support.sortDetached && b.compareDocumentPosition(a) === сравнить )) {

			// Выбираем первый элемент, связанный с предпочитаемым нами документом
			// Поддержка: IE 11+, Edge 17–18+
			// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
			// два документа; поверхностные сравнения работают.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument ==eferredDoc &&
				find.contains(preferredDoc, a) ) {
				возврат -1;
			}

			// Поддержка: IE 11+, Edge 17–18+
			// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
			// два документа; поверхностные сравнения работают.
			// eslint-disable-next-line eqeqeq
			if ( b === документ || b.ownerDocument ==eferredDoc &&
				find.contains(preferredDoc, b) ) {
				возврат 1;
			}

			// Сохраняем первоначальный порядок
			вернуть сортировку ввода?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ):
				0;
		}

		вернуть сравнение & 4 ? -1 : 1;
	};

	возвратный документ;
}

find.matches = функция(выражение, элементы) {
	вернуть find(expr, null, null, elements);
};

find.matchesSelector = function(elem, expr) {
	УстановитьДокумент(Элем);

	если ( documentIsHTML &&
		!nonnativeSelectorCache[ выражение + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test(выражение) )) {

		пытаться {
			var ret = match.call(elem, expr);

			// MatchSelector в IE 9 возвращает false на отключенных узлах
			if ( ret || support.disconnectedMatch ||

					// Также говорят, что отключенные узлы находятся в документе
					// фрагмент в IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				вернуть возврат;
			}
		} поймать ( е ) {
			NonnativeSelectorCache (выражение, правда);
		}
	}

	return find(expr, document, null, [elem]).length > 0;
};

find.contains = функция(контекст, элемент) {

	// При необходимости устанавливаем переменные документа
	// Поддержка: IE 11+, Edge 17–18+
	// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
	// два документа; поверхностные сравнения работают.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || контекст ) != документ ) {
		УстановитьДокумент (контекст);
	}
	вернуть jQuery.contains(контекст, элемент);
};


find.attr = функция(элемент, имя) {

	// При необходимости устанавливаем переменные документа
	// Поддержка: IE 11+, Edge 17–18+
	// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
	// два документа; поверхностные сравнения работают.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != документ ) {
		УстановитьДокумент(Элем);
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Не дайте себя обмануть свойствами Object.prototype (см. trac-13807)
		val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())?
			fn(элемент, имя, !documentIsHTML):
			неопределенный;

	если (значение!== неопределенное) {
		вернуть значение;
	}

	вернуть элемент.getAttribute(имя);
};

find.error = функция (сообщение) {
	throw new Error("Синтаксическая ошибка, нераспознанное выражение: " + msg );
};

/**
 * Сортировка документов и удаление дубликатов.
 * @param {ArrayLike} результаты
 */
jQuery.uniqueSort = функция (результаты) {
	вар элем,
		дубликаты = [],
		j = 0,
		я = 0;

	// Если мы *не знаем*, что можем обнаружить дубликаты, предполагаем их наличие
	//
	// Поддержка: Android <= 4.0+
	// Тестирование на обнаружение дубликатов непредсказуемо, поэтому предположим, что мы не можем
	// зависит от обнаружения дубликатов во всех браузерах без стабильной сортировки.
	hasDuulate = !support.sortStable;
	sortInput = !support.sortStable && слайс.call(результаты, 0);
	sort.call(результаты, sortOrder);

	если (имеет дубликат) {
		while ( ( elem = результаты [ i++ ] ) ) {
			если ( элем === результаты [ я ] ) {
				j = дубликаты.push(я);
			}
		}
		в то время как ( j-- ) {
			splice.call(результаты, дубликаты[j], 1);
		}
	}

	// Очистить ввод после сортировки, чтобы освободить объекты
	// См. https://github.com/jquery/sizzle/pull/225.
	sortInput = ноль;

	возврат результатов;
};

jQuery.fn.uniqueSort = функция() {
	return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
};

Выраж = jQuery.expr = {

	// Может быть настроен пользователем
	длина кэша: 50,

	createPseudo: markFunction,

	совпадение: matchExpr,

	attrHandle: {},

	находить: {},

	родственник: {
		">": { dir: "parentNode", first: true },
		" ": { каталог: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	предфильтр: {
		ATTR: функция (соответствие) {
			match[ 1 ] = match[ 1 ].replace(runescape, funescape);

			// Перемещаем данное значение в соответствие[3] независимо от того, заключено оно в кавычки или нет
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace(runescape, funescape);

			если ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			вернуть match.slice(0, 4);
		},

		РЕБЕНОК: функция (соответствие) {

			/* совпадения из matchExpr["CHILD"]
				1 тип (только|n-й|...)
				2 что (дочерний|типа)
				3 аргумента (четный|нечетный|\d*|\d*n([+-]\d+)?|...)
				4 xn-компонент аргумента xn+y ([+-]?\d*n|)
				5 знак xn-компонента
				6 х xn-компонента
				7 знак y-компонента
				8 лет y-компонента
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* требует аргумента
				если ( !match[ 3 ] ) {
					find.error(матч[0]);
				}

				// числовые параметры x и y для Expr.filter.CHILD
				// помните, что значение false/true соответственно равно 0/1
				совпадение[ 4 ] = +( совпадение[4] ?
					совпадение[ 5 ] + ( совпадение[ 6 ] || 1 ):
					2 * ( match[ 3 ] === "чётное" || совпадение[ 3 ] === "нечетное" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "нечетный" );

			// другие типы запрещают аргументы
			} иначе если ( match[ 3 ] ) {
				find.error(матч[0]);
			}

			ответный матч;
		},

		ПСЕВДО: функция(соответствие) {
			избыток вар,
				без кавычек = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				вернуть ноль;
			}

			// Принимаем аргументы в кавычках как есть
			если ( совпадение [ 3 ] ) {
				совпадение[ 2 ] = совпадение[ 4 ] || совпадение[ 5 ] || "";

			// Удалить лишние символы из аргументов, не заключенных в кавычки
			} else if (без кавычек && rpseudo.test(без кавычек) &&

				// Получаем лишнее из токенизации (рекурсивно)
				(избыток = токенизация(без ​​кавычек, правда)) &&

				// переход к следующей закрывающей скобке
				(excess = unquoted.indexOf( ")", unquoted.length - extra ) - unquoted.length )) {

				// превышение — отрицательный показатель
				match[0] = match[0].slice(0, превышение);
				match[2] = unquoted.slice(0, превышение);
			}

			// Возвращаем только те захваты, которые необходимы методу псевдофильтра (тип и аргумент)
			вернуть match.slice(0, 3);
		}
	},

	фильтр: {

		ТЕГ: функция (nodeNameSelector) {
			var ожидаемыйNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
			вернуть nodeNameSelector === "*" ?
				функция() {
					вернуть истину;
				} :
				функция( элемент ) {
					вернуть имя узла (элемент, ожидаемое имя узла);
				};
		},

		КЛАСС: функция (имя класса) {
			вар шаблон = classCache [имя класса + " " ];

			шаблон возврата ||
				(шаблон = новый RegExp( "(^|" + пробел + ")" + имя класса +
					"(" + пробел + "|$)" )) ) &&
				classCache(имякласса, функция(элемент) {
					вернуть шаблон.тест(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "не определено" &&
								elem.getAttribute("класс") ||
							""
					);
				});
		},

		ATTR: функция(имя, оператор, проверка) {
			функция возврата (элемент) {
				var result = find.attr(elem, name);

				если (результат == ноль) {
					оператор возврата === "!=";
				}
				если ( !оператор ) {
					вернуть истину;
				}

				результат += "";

				если (оператор === "=" ) {
					вернуть результат === проверить;
				}
				если (оператор === "!=" ) {
					вернуть результат !== проверить;
				}
				если (оператор === "^=" ) {
					вернуть проверку && result.indexOf(проверка) === 0;
				}
				если (оператор === "*=" ) {
					вернуть проверку && result.indexOf(проверка) > -1;
				}
				если (оператор === "$=" ) {
					вернуть проверку && result.slice( -check.length ) === проверка;
				}
				если (оператор === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf(проверка) > -1;
				}
				если (оператор === "|=" ) {
					вернуть результат === проверить || result.slice( 0, check.length + 1 ) === проверка + "-";
				}

				вернуть ложь;
			};
		},

		РЕБЕНОК: функция (тип, какой, _аргумент, первый, последний) {
			var simple = type.slice(0, 3) !== "nth",
				вперед = type.slice( -4 ) !== "последний",
				ofType = что === "типа";

			вернуть первый === 1 && последний === 0 ?

				// Ярлык для :nth-*(n)
				функция( элемент ) {
					вернуть !!elem.parentNode;
				} :

				функция (элемент, _context, xml) {
					кэш var, externalCache, узел, nodeIndex, начало,
						реж = просто! == вперед? "nextSibling" : "предыдущийSibling",
						родитель = элемент.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						разница = ложь;

					если (родитель) {

						// :(первый|последний|только)-(дочерний|типа)
						если (просто) {
							в то время как (реж) {
								узел = элемент;
								while ( ( узел = узел [ реж ​​] ) ) {
									если ( ofType ?
										имя_узла(узел, имя):
										node.nodeType === 1 ) {

										вернуть ложь;
									}
								}

								// Обратное направление для :only-* (если мы еще этого не сделали)
								start = dir = type === "only" && !start && "nextSibling";
							}
							вернуть истину;
						}

						начало = [вперед? родитель.firstChild: родитель.lastChild];

						// не-xml :nth-child(...) хранит данные кэша в `родителе`
						if (переслать && useCache) {

							// Ищем `elem` в ранее кэшированном индексе
							externalCache = родительский [expando] || (родитель[expando] = {});
							кэш = внешний кэш[тип] || [];
							nodeIndex = кэш[0] === dirruns && кэш[1];
							diff = индекс узла && кэш [ 2 ];
							node = nodeIndex && родительский.childNodes[nodeIndex];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Возврат к поиску `elem` с самого начала
								( diff = индекс узла = 0 ) || start.pop() ) ) {

								// При обнаружении кэшируем индексы на `родительском` и прерываем
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									externalCache[тип] = [dirruns, nodeIndex, diff];
									перерыв;
								}
							}

						} еще {

							// Используем ранее кэшированный индекс элемента, если он доступен
							если (useCache) {
								externalCache = элемент[expando] || (элемент[expando] = {});
								кэш = внешний кэш[тип] || [];
								nodeIndex = кэш[0] === dirruns && кэш[1];
								разница = индекс узла;
							}

							// xml :nth-child(...)
							// или :nth-last-child(...) или :nth(-last)?-of-type(...)
							если (разница === ложь) {

								// Используйте тот же цикл, что и выше, для поиска `elem` с самого начала
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = индекс узла = 0 ) || start.pop() ) ) {

									если (( ofType ?
										имя_узла(узел, имя):
										node.nodeType === 1 ) &&
										++разница ) {

										// Кэшируем индекс каждого встреченного элемента
										если (useCache) {
											внешнийCache = узел[expando] ||
												(узел[expando] = {});
											externalCache[тип] = [dirruns, diff];
										}

										если (узел === элем) {
											перерыв;
										}
									}
								}
							}
						}

						// Включаем смещение, затем проверяем размер цикла
						разница -= последний;
						вернуть разницу === сначала || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		ПСЕВДО: функция(псевдо, аргумент) {

			// имена псевдоклассов нечувствительны к регистру
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Приоритизация по чувствительности к регистру, если пользовательские псевдонимы добавляются с заглавными буквами
			// Помните, что setFilters наследует псевдонимы
			вар аргументы,
				fn = Выражение.псевдос[псевдо] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error("неподдерживаемое псевдо: " + псевдо);

			// Пользователь может использовать createPseudo, чтобы указать, что
			// аргументы необходимы для создания функции фильтра
			// так же, как это делает jQuery
			если (fn[expando]) {
				вернуть ФН (аргумент);
			}

			// Но сохраняем поддержку старых сигнатур
			если ( fn.length > 1 ) {
				args = [псевдо, псевдо, "", аргумент];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() )?
					markFunction(функция(семя, совпадения) {
						вар идентификатор,
							соответствует = fn(семя, аргумент),
							я = match.length;
						в то время как я-- ) {
							idx = indexOf.call(seed, matched[i]);
							семя[idx] = !(соответствует[idx] = соответствует[i]);
						}
					} ) :
					функция( элемент ) {
						вернуть fn(elem, 0, args);
					};
			}

			вернуть ФН;
		}
	},

	псевдонимы: {

		// Потенциально сложные псевдонимы
		нет: markFunction(функция(селектор) {

			// Обрезаем селектор, переданный на компиляцию
			// чтобы избежать обработки начального и конечного
			// пробелы как комбинаторы
			вар ввод = [],
				результаты = [],
				matcher = compile(selector.replace(rtrimCSS, "$1" ));

			возврат сопоставителя [expando]?
				markFunction(функция(семя, совпадения, _context, xml) {
					вар элем,
						unmatched = matcher(seed, null, xml, []),
						я = семя.длина;

					// Сопоставление элементов, которым не соответствует `matcher`
					в то время как я-- ) {
						если ( ( элем = непревзойденный [ я ] ) ) {
							семя[i] = !(соответствует[i] = элемент);
						}
					}
				} ) :
				функция (элемент, _context, xml) {
					ввод[0] = элемент;
					сопоставитель (вход, ноль, xml, результаты);

					// Не сохранять элемент
					// (см. https://github.com/jquery/sizzle/issues/299)
					ввод [0] = ноль;
					вернуть !results.pop();
				};
		} ),

		имеет: markFunction(функция(селектор) {
			функция возврата (элемент) {
				вернуть find(селектор, элемент).длина > 0;
			};
		} ),

		содержит: markFunction(функция(текст) {
			text = text.replace(runescape, funescape);
			функция возврата (элемент) {
				return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
			};
		} ),

		// "Представлен ли элемент селектором :lang()
		// основано исключительно на значении языка элемента
		// равен идентификатору C,
		// или начинается с идентификатора C, за которым сразу следует "-".
		// Сопоставление C со значением языка элемента выполняется без учета регистра.
		// Идентификатор C не обязательно должен быть допустимым названием языка."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		язык: markFunction(функция(язык) {

			// значение языка должно быть действительным идентификатором
			if ( !ridentifier.test(lang || "" )) {
				find.error("неподдерживаемый язык: " + язык);
			}
			lang = lang.replace(runescape, funescape).toLowerCase();
			функция возврата (элемент) {
				вар элемланг;
				делать {
					если (( elemLang = documentIsHTML ?
						элем.язык:
						elem.getAttribute("xml:lang") || elem.getAttribute("lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf(lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1);
				вернуть ложь;
			};
		} ),

		// Разнообразный
		цель: функция (элемент) {
			var hash = window.location && window.location.hash;
			вернуть хеш && hash.slice( 1 ) === elem.id;
		},

		корень: функция (элемент) {
			вернуть элемент === documentElement;
		},

		фокус: функция (элемент) {
			вернуть элемент === SafeActiveElement() &&
				документ.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Логические свойства
		включено: createDisabledPseudo(false),
		отключено: createDisabledPseudo(true),

		проверено: функция (элемент) {

			// В CSS3 :checked должен возвращать как отмеченные, так и выбранные элементы
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return (nodeName(elem, "input") && !!elem.checked ) ||
				(nodeName(elem, "option") && !!elem.selected );
		},

		выбрано: функция( элем ) {

			// Поддержка: IE <=11+
			// Доступ к свойству selectedIndex
			// заставляет браузер рассматривать опцию по умолчанию как
			// выбирается, когда находится в optgroup.
			если (elem.parentNode) {
				// eslint-disable-next-line без неиспользуемых-выражений
				элемент.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Содержание
		пусто: функция (элем) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty отменяется элементом (1) или узлами содержимого (text: 3; cdata: 4; ссылка на объект: 5),
			// но не другими (комментарий: 8; инструкция обработки: 7; и т.д.)
			// nodeType < 6 работает, поскольку атрибуты (2) не отображаются как дочерние
			for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
				если (elem.nodeType <6) {
					вернуть ложь;
				}
			}
			вернуть истину;
		},

		родитель: функция (элемент) {
			return !Expr.pseudos.empty(elem);
		},

		// Типы элементов/входных данных
		заголовок: функция (элемент) {
			вернуть rheader.test(elem.nodeName);
		},

		ввод: функция (элемент) {
			вернуть rinputs.test(elem.nodeName);
		},

		кнопка: функция (элемент) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				имя_узла(элемент, «кнопка»);
		},

		текст: функция (элемент) {
			вар атрибут;
			return nodeName( elem, "input") && elem.type === "text" &&

				// Поддержка: только IE <10
				// Появляются новые значения атрибута HTML5 (например, «поиск»).
				// с elem.type === "текст"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "текст");
		},

		// Позиция в коллекции
		сначала: createPositionalPseudo( function() {
			вернуть [0];
		} ),

		последнее: createPositionalPseudo (функция (_matchIndexes, длина) {
			возврат [длина - 1];
		} ),

		eq: createPositionalPseudo (функция (_matchIndexes, длина, аргумент) {
			вернуть [аргумент <0? аргумент + длина: аргумент];
		} ),

		даже: createPositionalPseudo (функция (matchIndexes, длина) {
			вар я = 0;
			для ( ; я < длина; я += 2 ) {
				matchIndexes.push(я);
			}
			вернуть индексы совпадений;
		} ),

		нечетно: createPositionalPseudo( function( matchIndexes, length ) {
			вар я = 1;
			для ( ; я < длина; я += 2 ) {
				matchIndexes.push(я);
			}
			вернуть индексы совпадений;
		} ),

		lt: createPositionalPseudo (функция (matchIndexes, длина, аргумент) {
			вар я;

			если (аргумент <0) {
				я = аргумент + длина;
			} else if (аргумент > длина) {
				я = длина;
			} еще {
				я = аргумент;
			}

			для ( ; --i >= 0; ) {
				matchIndexes.push(я);
			}
			вернуть индексы совпадений;
		} ),

		gt: createPositionalPseudo(функция(matchIndexes, length, аргумент) {
			вар я = аргумент <0? аргумент + длина: аргумент;
			для ( ; ++i < длина; ) {
				matchIndexes.push(я);
			}
			вернуть индексы совпадений;
		} )
	}
};

Выражение.псевдос.nth = Выражение.псевдос.eq;

// Добавляем псевдонимы типа кнопки/ввода
for (я в {радио: правда, флажок: правда, файл: правда, пароль: правда, изображение: правда}) {
	Expr.pseudos[ i ] = createInputPseudo(i);
}
for (я в { submit: true, reset: true }) {
	Expr.pseudos[ i ] = createButtonPseudo(i);
}

// Простой API для создания новых setFilters
функция setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = новый setFilters();

функция tokenize(селектор, parseOnly) {
	var соответствует, совпадение, токены, тип,
		до сих пор, группы, префильтры,
		кэшированный = tokenCache [селектор + ""];

	если (кэшировано) {
		вернуть parseOnly? 0: кэшированный.срез(0);
	}

	до сих пор = селектор;
	группы = [];
	preFilters = Выражение.preFilter;

	пока (пока) {

		// Запятая и первый запуск
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			если ( совпадение ) {

				// Не используйте конечные запятые как допустимые
				soFar = soFar.slice( match[ 0 ].length ) || до сих пор;
			}
			groups.push( (токены = []));
		}

		соответствует = ложь;

		// Комбинаторы
		если ( ( совпадение = rleadingCombinator.exec ( soFar ) ) ) {
			сопоставлено = match.shift();
			токены.push( {
				значение: соответствует,

				// Выбрасываем комбинаторы потомков в пространство
				тип: match[ 0 ].replace( rtrimCSS, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Фильтры
		for (введите Expr.filter) {
			if ( ( match = matchExpr[ тип ].exec( soFar ) ) && ( !preFilters[ тип ] ||
				( совпадение = preFilters [тип ] ( совпадение ) ) ) {
				сопоставлено = match.shift();
				токены.push( {
					значение: соответствует,
					тип: тип,
					совпадения: совпадение
				});
				soFar = soFar.slice( matched.length );
			}
		}

		если ( !совпадает ) {
			перерыв;
		}
	}

	// Возвращаем длину недопустимого превышения
	// если мы просто анализируем
	// В противном случае выдать ошибку или вернуть токены
	если (parseOnly) {
		вернуть soFar.length;
	}

	вернуться до сих пор?
		find.error(селектор):

		// Кэшируем токены
		tokenCache(селектор, группы).slice(0);
}

функция toSelector(токены) {
	вар я = 0,
		len = токены.длина,
		селектор = "";
	для ( ; я < len; я++ ) {
		селектор += токены[i].value;
	}
	возвратный селектор;
}

функция addCombinator(сопоставитель, комбинатор, база) {
	вар реж = комбинатор.каталог,
		пропустить = комбинатор.следующий,
		ключ = пропустить || реж.,
		checkNonElements = base && key === "parentNode",
		DoneName = Done++;

	вернуть комбинатор.первый?

		// Проверка ближайшего предка/предыдущего элемента
		функция (элемент, контекст, xml) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					возврат сопоставителя (elem, context, xml);
				}
			}
			вернуть ложь;
		} :

		// Проверка всех предков/предшествующих элементов
		функция (элемент, контекст, xml) {
			вар oldCache, внешнийCache,
				newCache = [dirruns, DoneName];

			// Мы не можем устанавливать произвольные данные в узлах XML, поэтому они не получают выгоды от кэширования комбинатора
			если ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher(elem, context, xml) ) {
							вернуть истину;
						}
					}
				}
			} еще {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						externalCache = элемент[expando] || (элемент[expando] = {});

						if (пропустить && имя_узла(элемент, пропустить)) {
							элем = элем[дир] || элем;
						} else if ( (oldCache = externalCache[key]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === DoneName ) {

							// Назначаем newCache, чтобы результаты распространялись на предыдущие элементы
							return (newCache[2] = oldCache[2]);
						} еще {

							// Повторно используем newcache, чтобы результаты распространялись на предыдущие элементы
							externalCache [ключ] = newCache;

							// Совпадение означает, что мы закончили; неудача означает, что мы должны продолжать проверку
							if ( ( newCache[ 2 ] = matcher(elem, context, xml) ) ) {
								вернуть истину;
							}
						}
					}
				}
			}
			вернуть ложь;
		};
}

функция elementMatcher(сопоставители) {
	вернуть matchers.length > 1?
		функция (элемент, контекст, xml) {
			вар я = matchers.length;
			в то время как я-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					вернуть ложь;
				}
			}
			вернуть истину;
		} :
		совпадения [ 0 ];
}

function MultipleContexts(селектор, контексты, результаты) {
	вар я = 0,
		лен = контексты.длина;
	для ( ; я < len; я++ ) {
		find(селектор, контексты[i], результаты);
	}
	возврат результатов;
}

функция конденсации (непревзойденный, карта, фильтр, контекст, xml) {
	вар элем,
		новыйUnmatched = [],
		я = 0,
		len = непревзойденная.длина,
		сопоставлено = карта! = ноль;

	для ( ; я < len; я++ ) {
		если ( ( элем = непревзойденный [ я ] ) ) {
			if ( !filter || filter(elem, context, xml) ) {
				newUnmatched.push(элемент);
				если (сопоставлено) {
					карта.push(я);
				}
			}
		}
	}

	вернуть новыйUnmatched;
}

function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
	if ( postFilter && !postFilter[expando]) {
		postFilter = setMatcher(postFilter);
	}
	if ( postFinder && !postFinder[expando]) {
		postFinder = setMatcher(postFinder, postSelector);
	}
	return markFunction(функция(семя, результаты, контекст, xml) {
		вар темп, я, элем, matcherOut,
			предварительная карта = [],
			постМап = [],
			ранее существовавшие = результаты.длина,

			// Получаем начальные элементы из начального числа или контекста
			элементы = семя ||
				MultipleContexts( селектор || "*",
					контекст.nodeType? [контекст]: контекст, []),

			// Префильтр для получения входных данных сопоставителя, сохраняющий карту для синхронизации исходных результатов
			matcherIn = preFilter && (seed || !selector)?
				конденсировать(elems, preMap, preFilter, context, xml):
				элементы;

		если (сопоставитель) {

			// Если у нас есть postFinder, или отфильтрованное начальное значение, или postFilter без начального значения
			// или ранее существовавшие результаты,
			matcherOut = postFinder || (семя? preFilter: ранее существовавший || postFilter)?

				// ...необходима промежуточная обработка
				[] :

				// ...иначе использовать результаты напрямую
				Результаты;

			// Находим основные совпадения
			matcher(matcherIn, matcherOut, контекст, xml);
		} еще {
			matcherOut = matcherIn;
		}

		// Применяем постфильтр
		если (постфильтр) {
			temp = конденсировать (matcherOut, postMap);
			postFilter(temp, [], контекст, xml);

			// Отменяем совпадение с неудачными элементами, перемещая их обратно в matcherIn
			я = временная длина;
			в то время как я-- ) {
				если ( ( элем = temp[ я ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		если (семя) {
			если ( postFinder || preFilter ) {
				если ( postFinder ) {

					// Получаем окончательный результат matcherOut, сжимая это промежуточное звено в контексты postFinder
					температура = [];
					я = matcherOut.length;
					в то время как я-- ) {
						если ( ( элем = matcherOut[ я ] ) ) {

							// Восстанавливаем matcherIn, так как elem ещё не окончательное совпадение
							temp.push(( matcherIn[i] = elem));
						}
					}
					postFinder(null, (matcherOut = []), temp, xml);
				}

				// Перемещаем совпавшие элементы из начального числа в результаты, чтобы обеспечить их синхронизацию
				я = matcherOut.length;
				в то время как я-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call(seed, elem): preMap[i]) > -1) {

						семя[temp] = !(результаты[temp] = элемент);
					}
				}
			}

		// Добавляем элементы в результаты через postFinder, если он определен
		} еще {
			matcherOut = конденсировать(
				matcherOut === результаты?
					matcherOut.splice( ранее существовавший, matcherOut.length ):
					matcherOut
			);
			если ( postFinder ) {
				postFinder (ноль, результаты, matcherOut, xml);
			} еще {
				push.apply(результаты, matcherOut);
			}
		}
	});
}

функция matcherFromTokens(токены) {
	вар checkContext, сопоставитель, j,
		len = токены.длина,
		leadRelative = Expr.relative[ токены[ 0 ].type ],
		неявныйRelative = LeadingRelative || Выражение относительное[ " " ],
		я = ведущий относительный? 1 : 0,

		// Базовый механизм сопоставления гарантирует, что элементы доступны из контекста(ов) верхнего уровня.
		matchContext = addCombinator(функция(элемент) {
			вернуть элемент === checkContext;
		}, неявныйОтносительный, правда),
		matchAnyContext = addCombinator(функция(элемент) {
			вернуть indexOf.call(checkContext, elem) > -1;
		}, неявныйОтносительный, правда),
		сопоставители = [функция(elem, context, xml) {

			// Поддержка: IE 11+, Edge 17–18+
			// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
			// два документа; поверхностные сравнения работают.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || контекст != внешнийконтекст )) || (
				(checkContext = контекст).nodeType?
					matchContext(элемент, контекст, xml):
					matchAnyContext(элемент, контекст, xml));

			// Избегаем зависания на элементе
			// (см. https://github.com/jquery/sizzle/issues/299)
			проверкаКонтекст = ноль;
			вернуть возврат;
		} ];

	для ( ; я < len; я++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			сопоставители = [addCombinator(elementMatcher(сопоставители), сопоставитель)];
		} еще {
			matcher = Expr.filter[ tokens[i].type].apply(null, tokens[i].matches);

			// Возвращаем специальный результат при обнаружении позиционного сопоставления
			если (сопоставитель[расширение]) {

				// Находим следующий относительный оператор (если есть) для правильной обработки
				j = ++я;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						перерыв;
					}
				}
				вернуть setMatcher(
					i > 1 && elementMatcher(сопоставители),
					я > 1 && toSelector(

						// Если предыдущий токен был комбинатором-потомком, вставьте неявный любой элемент `*`
						tokens.slice( 0, i - 1 )
							.concat( { значение: токены[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					совпадение,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j <len && toSelector(токены)
				);
			}
			matchers.push(сопоставитель);
		}
	}

	вернуть elementMatcher(сопоставители);
}

функция matcherFromGroupMatchers(elementMatchers, setMatchers) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = функция (семя, контекст, xml, результаты, внешний) {
			вар элем, j, matcher,
				сопоставленоCount = 0,
				я = "0",
				непревзойденный = семя && [],
				setMatched = [],
				contextBackup = внешний контекст,

				// У нас всегда должны быть либо исходные элементы, либо внешний контекст
				элементы = семя || byElement && Expr.find.TAG( "*", самый внешний),

				// Используйте целочисленные каталоги, если это самое внешнее сопоставление
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				лен = элементы.длина;

			если (самый дальний) {

				// Поддержка: IE 11+, Edge 17–18+
				// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
				// два документа; поверхностные сравнения работают.
				// eslint-disable-next-line eqeqeq
				внешнийконтекст = контекст == документ || контекст || крайний;
			}

			// Добавляем элементы, передавая elementMatchers непосредственно в результаты
			// Поддержка: только iOS <= 7–9
			// Допускать совпадение свойств NodeList (IE: "length"; Safari: <number>)
			// элементы по идентификатору. (см. трассу-14142)
			for ( ; я !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Поддержка: IE 11+, Edge 17–18+
					// IE/Edge иногда выдает ошибку «Отказано в доступе» при строгом сравнении
					// два документа; поверхностные сравнения работают.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != документ ) {
						УстановитьДокумент(Элем);
						xml = !DocumentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher(elem, context || document, xml )) {
							push.call(результаты, элемент);
							перерыв;
						}
					}
					если (самый дальний) {
						dirruns = dirrunsUnique;
					}
				}

				// Отслеживание несовпадающих элементов для установленных фильтров
				если ( bySet ) {

					// Они пройдут все возможные совпадения
					if ( ( elem = !matcher && elem )) {
						matchCount--;
					}

					// Удлиняем массив для каждого элемента, совпадающего или нет
					если (семя) {
						unmatched.push(элемент);
					}
				}
			}

			// `i` теперь является количеством посещенных выше элементов, и добавляем его в `matchedCount`
			// делает последнее неотрицательным.
			matchedCount += я;

			// Применяем фильтры набора к несовпадающим элементам
			// ПРИМЕЧАНИЕ. Это можно пропустить, если нет несовпадающих элементов (например, `matchedCount`
			// равно `i`), если только мы не посетили _любые_ элементы в приведенном выше цикле, потому что у нас есть
			// нет сопоставлений элементов и нет начального значения.
			// Увеличение исходной строки "0" `i` позволяет `i` оставаться строкой только в этом
			// случай, в результате которого будет получен `matchedCount` "00", который отличается от `i`, но также
			// числовой ноль.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					сопоставитель (непревзойденный, setMatched, контекст, xml);
				}

				если (семя) {

					// Реинтегрируем совпадения элементов, чтобы исключить необходимость сортировки
					если ( matchedCount > 0 ) {
						в то время как я-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[i] = pop.call(результаты);
							}
						}
					}

					// Отбрасываем значения заполнителей индекса, чтобы получать только фактические совпадения
					setMatched = конденсировать (setMatched);
				}

				// Добавляем совпадения в результаты
				push.apply(результаты, setMatched);

				// Сопоставление набора без семян после нескольких успешных сопоставлений требует сортировки
				if (самый внешний && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort(результаты);
				}
			}

			// Переопределить манипуляции с глобальными переменными с помощью вложенных сопоставлений
			если (самый дальний) {
				dirruns = dirrunsUnique;
				внешнийконтекст = contextBackup;
			}

			возврат непревзойденный;
		};

	вернуть поSet?
		markFunction(superMatcher):
		суперматчер;
}

function compile( selector, match /* Только для внутреннего использования */ ) {
	вар я,
		setMatchers = [],
		elementMatchers = [],
		кэшированный = compilerCache[селектор + ""];

	если ( !кэшировано ) {

		// Генерируем функцию рекурсивных функций, которую можно использовать для проверки каждого элемента
		если (! совпадение) {
			совпадение = токенизация (селектор);
		}
		я = совпадение.длина;
		в то время как я-- ) {
			кэшировано = matcherFromTokens(match[i]);
			if (кешировано[expando]) {
				setMatchers.push(кэшировано);
			} еще {
				elementMatchers.push(кэшировано);
			}
		}

		// Кэшируем скомпилированную функцию
		кэшированный = compilerCache(селектор,
			matcherFromGroupMatchers(elementMatchers, setMatchers));

		// Сохраняем селектор и токенизацию
		кэшированный.селектор = селектор;
	}
	возврат кэшируется;
}

/**
 * Функция выбора низкого уровня, которая работает с скомпилированными jQuery.
 * функции выбора
 * @param Селектор {String|Function} Селектор или предварительно скомпилированный
 * функция селектора, созданная с помощью компиляции селектора jQuery
 * @param {Элемент} контекст
 * @param {Массив} [результаты]
 * @param {Array} [seed] Набор элементов для сопоставления
 */
function select(селектор, контекст, результаты, начальное число) {
	вар я, жетоны, токен, тип, найти,
		скомпилированный = селектор typeof === "функция" && селектор,
		match = !seed && tokenize( (селектор = компилированный.селектор || селектор));

	результаты = результаты || [];

	// Попытаемся минимизировать операции, если в списке только один селектор и нет начального значения
	// (последнее из которых гарантирует нам контекст)
	если ( match.length === 1 ) {

		// Уменьшаем контекст, если ведущим составным селектором является идентификатор
		токены = совпадение[0] = совпадение[0].slice(0);
		if ( tokens.length > 2 && ( token = tokens[0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			контекст = ( Выражение.найти.ИД(
				token.matches[0].replace(runescape, funescape),
				контекст
			) || [] )[ 0 ];
			если ( !контекст ) {
				возврат результатов;

			// Предварительно скомпилированные средства сопоставления по-прежнему будут проверять происхождение, поэтому поднимитесь на уровень выше
			} еще если (скомпилировано) {
				контекст = context.parentNode;
			}

			селектор = selector.slice( tokens.shift().value.length );
		}

		// Получение начального набора для сопоставления справа налево
		я = matchExpr.needsContext.test(селектор)? 0: длина токена;
		в то время как я-- ) {
			токен = токены [я];

			// Прерываем, если попадаем в комбинатор
			if ( Выражение.относительное [ ( тип = токен.тип ) ] ) {
				перерыв;
			}
			если ( ( найти = Выражение.найти[ тип ] ) ) {

				// Поиск, расширение контекста для ведущих одноуровневых комбинаторов
				если ( ( семя = найти(
					token.matches[0].replace(runescape, funescape),
					rsibling.test(токены[0].type) &&
						testContext( context.parentNode ) || контекст
				) ) ) {

					// Если начальное число пусто или не осталось токенов, мы можем вернуться раньше
					токены.splice(я, 1);
					селектор = семя.длина && toSelector(токены);
					если (!селектор) {
						push.apply(результаты, семя);
						возврат результатов;
					}

					перерыв;
				}
			}
		}
	}

	// Компилируем и выполняем функцию фильтрации, если она не указана
	// Укажите `match`, чтобы избежать повторной токенизации, если мы изменили селектор выше
	( скомпилировано || скомпилировать( селектор, совпадение ) )(
		семя,
		контекст,
		!документIsHTML,
		Результаты,
		!контекст || rsibling.test(селектор) && testContext(context.parentNode) || контекст
	);
	возврат результатов;
}

// Одноразовые задания

// Поддержка: Android <= 4.0–4.1+
// Стабильность сортировки
support.sortStable =expando.split("" ).sort( sortOrder ).join( "" ) ===expando;

// Инициализируем документ по умолчанию
УстановитьДокумент();

// Поддержка: Android <= 4.0–4.1+
// Отдельные узлы сбивчиво следуют *друг за другом*
support.sortDetached = утверждать(функция(эл) {

	// Должен вернуть 1, но возвращает 4 (далее)
	return el.compareDocumentPosition( document.createElement( "fieldset" )) & 1;
});

jQuery.find = найти;

// Устарело
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// Они всегда были частными, но раньше документировались как часть
// Sizzle, поэтому давайте пока сохраним их в целях обратной совместимости.
find.compile = скомпилировать;
find.select = выбрать;
find.setDocument = setDocument;
find.tokenize = токенизировать;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* включение eslint */

} )();


var dir = функция (elem, dir, до тех пор, пока) {
	вар соответствует = [],
		усечь = до тех пор, пока !== не определено;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		если ( elem.nodeType === 1 ) {
			if ( truncate && jQuery(elem ).is( до тех пор ) ) {
				перерыв;
			}
			match.push(элемент);
		}
	}
	возврат соответствует;
};


вар братья и сестры = функция ( n, элем ) {
	вар соответствует = [];

	для (; n; n = n.nextSibling) {
		if ( n.nodeType === 1 && n !== elem ) {
			match.push(n);
		}
	}

	возврат соответствует;
};


вар rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([az][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>( ?:<\/\1>|)$/i );



// Реализуйте идентичную функциональность для фильтра, а не для
функция winnow(элементы, квалификатор, not) {
	if ( isFunction( квалификатор ) ) {
		return jQuery.grep( elements, function(elem, i) {
			return !!qualifier.call(elem, i, elem) !== not;
		});
	}

	// Один элемент
	если (квалификатор.nodeType) {
		return jQuery.grep( elements, function(elem) {
			return ( спецификатор elem === ) !== нет;
		});
	}

	// Массив элементов (jQuery, аргументы, массив)
	if ( квалификатор typeof !== "string" ) {
		return jQuery.grep( elements, function(elem) {
			return ( indexOf.call( квалификатор, elem ) > -1 ) !== нет;
		});
	}

	// Фильтруется напрямую как для простых, так и для сложных селекторов
	return jQuery.filter( квалификатор, elements, not);
}

jQuery.filter = function(expr, elems, not) {
	вар элем = элемс [0];

	если не ) {
		выражение = ":not(" + выражение + ")";
	}

	if (elems.length === 1 && elem.nodeType === 1) {
		вернуть jQuery.find.matchesSelector(elem, expr)? [ элем ] : [];
	}

	return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
		вернуть элемент.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	найти: функция(селектор) {
		вар я, Рет,
			len = this.length,
			я = это;

		if ( селектор типа !== "строка" ) {
			return this.pushStack( jQuery( селектор ).filter( function() {
				для (я = 0; я <len; я++) {
					if ( jQuery.contains( self[ i ], this ) ) {
						вернуть истину;
					}
				}
			} ) );
		}

		ret = this.pushStack([]);

		для (я = 0; я <len; я++) {
			jQuery.find(селектор, self[i], ret);
		}

		вернуть len > 1? jQuery.uniqueSort(рет): Рет;
	},
	фильтр: функция(селектор) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	нет: функция(селектор) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	это: функция (селектор) {
		вернуть !!веять(
			этот,

			// Если это позиционный/относительный селектор, проверяем членство в возвращаемом наборе
			// поэтому $("p:first").is("p:last") не вернет true для документа с двумя "p".
			Селектор typeof === "строка" && rneedsContext.test(селектор)?
				jQuery (селектор):
				селектор || [],
			ЛОЖЬ
		).длина;
	}
});


// Инициализируем объект jQuery


// Центральная ссылка на корень jQuery(document)
вар rootjQuery,

	// Простой способ проверки HTML-строк
	// Установите приоритет #id над <tag>, чтобы избежать XSS через location.hash (trac-9521)
	// Строгое распознавание HTML (trac-11290: должно начинаться с <)
	// Ярлык простого случая #id для скорости
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = функция (селектор, контекст, корень) {
		вар совпадение, элем;

		// РУЧКА: $(""), $(null), $(не определено), $(false)
		если (!селектор) {
			верните это;
		}

		// Метод init() принимает альтернативный rootjQuery
		// поэтому миграция может поддерживать jQuery.sub (gh-2101)
		корень = корень || rootjQuery;

		// Обработка строк HTML
		if ( селектор typeof === "строка" ) {
			if ( selector[ 0 ] === "<" &&
				селектор[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Предположим, что строки, начинающиеся и заканчивающиеся <>, являются HTML и пропускают проверку регулярных выражений
				совпадение = [ноль, селектор, ноль];

			} еще {
				match = rquickExpr.exec (селектор);
			}

			// Сопоставьте HTML или убедитесь, что для #id не указан контекст
			if ( совпадение && ( совпадение [ 1 ] || ! контекст )) {

				// РУЧКА: $(html) -> $(массив)
				если ( совпадение [ 1 ] ) {
					контекст = контекст экземпляра jQuery? контекст[0]: контекст;

					// Возможность запуска скриптов верна для обратной совместимости
					// Намеренно выдаем ошибку, если parseHTML отсутствует
					jQuery.merge( это, jQuery.parseHTML(
						совпадение[ 1 ],
						контекст && context.nodeType ? context.ownerDocument || контекст: документ,
						истинный
					) );

					// РУЧКА: $(html, реквизит)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for (соответствие в контексте) {

							// Свойства контекста, если это возможно, вызываются как методы
							если ( isFunction ( это [ совпадение ] ) ) {
								это[соответствие](контекст[соответствие]);

							// ...и иначе устанавливаем как атрибуты
							} еще {
								this.attr(соответствие, контекст[соответствие]);
							}
						}
					}

					верните это;

				// РУЧКА: $(#id)
				} еще {
					elem = document.getElementById(match[2]);

					если ( элем ) {

						// Внедряем элемент непосредственно в объект jQuery
						это[0] = элемент;
						this.длина = 1;
					}
					верните это;
				}

			// РУЧКА: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return (контекст || корень).find(селектор);

			// РУЧКА: $(выражение, контекст)
			// (что эквивалентно: $(context).find(expr)
			} еще {
				вернуть this.constructor(context).find(селектор);
			}

		// РУЧКА: $(DOMElement)
		} еще если (selector.nodeType) {
			это[0] = селектор;
			this.длина = 1;
			верните это;

		// РУЧКА: $(функция)
		// Ярлык для готового документа
		} Еще если (isFunction(селектор)) {
			вернуть root.ready !== не определено?
				root.ready(селектор):

				// Выполнить немедленно, если готовности нет
				селектор (jQuery);
		}

		вернуть jQuery.makeArray(селектор, это);
	};

// Передаем функции инициализации прототип jQuery для последующего создания экземпляра
init.prototype = jQuery.fn;

// Инициализируем центральную ссылку
rootjQuery = jQuery(документ);


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Методы, которые гарантированно создают уникальный набор при запуске из уникального набора
	гарантированныйУникальный = {
		дети: правда,
		содержание: правда,
		следующий: правда,
		предыдущая: правда
	};

jQuery.fn.extend( {
	имеет: функцию(цель) {
		вар цели = jQuery(цель, это),
			l = цели.длина;

		верните этот.фильтр(функция() {
			вар я = 0;
			для ( ; я < l; я++ ) {
				if ( jQuery.contains( this, Target[ i ] ) ) {
					вернуть истину;
				}
			}
		});
	},

	ближайшее: функция (селекторы, контекст) {
		вар кур,
			я = 0,
			l = эта.длина,
			соответствует = [],
			цели = селекторы типов !== "строка" && jQuery(селекторы);

		// Позиционные селекторы никогда не совпадают, поскольку нет контекста _selection_
		if (!rneedsContext.test(селекторы)) {
			для ( ; я < l; я++ ) {
				for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

					// Всегда пропускаем фрагменты документа
					if (cur.nodeType <11 && (targets?
						цели.индекс(cur) > -1:

						// Не передавайте в jQuery#find неэлементы
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector(cur, селекторы) ) ) {

						matched.push(cur);
						перерыв;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ): matched );
	},

	// Определяем положение элемента в наборе
	индекс: функция (элем) {

		// Нет аргумента, возвращаем индекс в родительском элементе
		если ( !elem ) {
			return (this[0] && this[0].parentNode)? this.first().prevAll().length : -1;
		}

		// Индекс в селекторе
		if ( typeof elem === "строка" ) {
			return indexOf.call(jQuery(elem), this[0]);
		}

		// Находим позицию нужного элемента
		вернуть indexOf.call( это,

			// Если он получает объект jQuery, используется первый элемент
			элемент.jquery? элем[0]: элем
		);
	},

	добавить: функция (селектор, контекст) {
		верните этот.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery(селектор, контекст))
			)
		);
	},

	addBack: функция (селектор) {
		верните this.add(селектор == null?
			this.prevObject: this.prevObject.filter(селектор)
		);
	}
});

функция-брат (cur, dir) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	вернуть собаку;
}

jQuery.each( {
	родитель: функция (элемент) {
		вар родительский = elem.parentNode;
		вернуть родительский && родительский.nodeType !== 11? родитель: ноль;
	},
	родители: функция( элем ) {
		return dir(elem, "parentNode");
	},
	РодителиУнтил: функция (элем, _i, до тех пор, пока) {
		return dir(elem, "parentNode", до тех пор, пока);
	},
	следующий: функция( элем ) {
		вернуть родного брата (elem, «nextSibling»);
	},
	предыдущая: функция( элем ) {
		return sibling(elem, "previousSibling");
	},
	nextAll: функция (элемент) {
		return dir(elem, "nextSibling");
	},
	предыдущее: функция (элемент) {
		return dir(elem, "previousSibling");
	},
	nextUntil: функция (elem, _i, до тех пор, пока) {
		return dir(elem, "nextSibling", до тех пор, пока );
	},
	prevUntil: функция (elem, _i, до тех пор, пока) {
		return dir(elem, "previousSibling", до тех пор, пока );
	},
	братья и сестры: функция (элем) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	дети: функция (элемент) {
		вернуть братьев и сестер (elem.firstChild);
	},
	содержимое: функция (элемент) {
		if ( elem.contentDocument != null &&

			// Поддержка: IE 11+
			// Элементы <object> без атрибута `data` имеют объект
			// `contentDocument` с `нулевым` прототипом.
			getProto(elem.contentDocument) ) {

			вернуть элемент.contentDocument;
		}

		// Поддержка: только IE 9–11, только iOS 7, только браузер Android <= 4.3
		// Считаем элемент шаблона обычным в браузерах, которые
		// не поддерживаем это.
		if (nodeName(elem, "шаблон")) {
			элем = элем.контент || элем;
		}

		return jQuery.merge( [], elem.childNodes);
	}
}, функция(имя, fn) {
	jQuery.fn[имя] = функция(пока, селектор) {
		var match = jQuery.map( this, fn, до тех пор, пока );

		if ( name.slice( -5 ) !== "До" ) {
			селектор = до;
		}

		if ( селектор && селектор типа === "строка" ) {
			соответствует = jQuery.filter(селектор, соответствует);
		}

		если ( this.length > 1 ) {

			// Удаляем дубликаты
			if ( !guarantedUnique[имя]) {
				jQuery.uniqueSort(соответствует);
			}

			// Обратный порядок для родителей* и предыдущих производных
			если (rparentsprev.test(имя)) {
				соответствует.обратный();
			}
		}

		вернуть this.pushStack(соответствует);
	};
});
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Конвертируем параметры в формате String в параметры в формате Object
функция createOptions(опции) {
	вар объект = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		объект[флаг] = правда;
	});
	вернуть объект;
}

/*
 * Создайте список обратных вызовов, используя следующие параметры:
 *
 * options: необязательный список опций, разделенных пробелами, которые изменят способ
 * поведение списка обратных вызовов или более традиционный объект опции
 *
 * По умолчанию список обратных вызовов действует как список обратных вызовов для событий и может быть
 * «выстрелил» несколько раз.
 *
 * Возможные варианты:
 *
 * Once: гарантирует, что список обратных вызовов может быть запущен только один раз (например, отложенный)
 *
 * память: будет отслеживать предыдущие значения и вызывать любой добавленный обратный вызов
 * после того, как список был уволен сразу с последним "запомненным"
 * значения (например, отложенное)
 *
 * уникальный: гарантирует, что обратный вызов можно будет добавить только один раз (в списке нет дубликатов)
 *
 * stopOnFalse: прерывание вызовов, когда обратный вызов возвращает false
 *
 */
jQuery.Callbacks = функция (опции) {

	// При необходимости преобразуем параметры из строкового формата в объектный формат
	// (сначала мы проверяем кеш)
	options = typeof options === "строка" ?
		createOptions(опции):
		jQuery.extend( {}, параметры);

	var // Флаг, чтобы узнать, активен ли в данный момент список
		стрельба,

		// Последнее значение срабатывания для незабываемых списков
		Память,

		// Флаг, чтобы узнать, был ли список уже запущен
		уволенный,

		// Флаг, предотвращающий срабатывание
		заперто,

		// Фактический список обратных вызовов
		список = [],

		// Очередь выполнения данных для повторяющихся списков
		очередь = [],

		// Индекс текущего обратного вызова (изменяется путем добавления/удаления по мере необходимости)
		Индекс стрельбы = -1,

		// Запускаем обратные вызовы
		огонь = функция() {

			// Принудить к одиночному срабатыванию
			заблокировано = заблокировано || варианты.один раз;

			// Выполняем обратные вызовы для всех ожидающих выполнения,
			// учитываем переопределения fireIndex и изменения во время выполнения
			выстрелил = выстрелил = правда;
			for (; очередь.длина; fireIndex = -1) {
				память = очередь.сдвиг();
				while (++firingIndex <list.length) {

					// Запускаем обратный вызов и проверяем досрочное завершение
					если (список[fireIndex].apply(память[0], память[1]) === false &&
						options.stopOnFalse ) {

						// Переходим в конец и забываем данные, чтобы .add не запускался повторно
						индекс стрельбы = список.длина;
						память = ложь;
					}
				}
			}

			// Забудем данные, если мы с ними закончили
			если (!options.memory) {
				память = ложь;
			}

			стрельба = ложь;

			// Очистка, если мы закончили стрельбу навсегда
			если (заблокировано) {

				// Сохраняем пустой список, если у нас есть данные для будущих вызовов добавления
				если (память) {
					список = [];

				// В противном случае этот объект тратится
				} еще {
					список = "";
				}
			}
		},

		// Фактический объект обратных вызовов
		сам = {

			// Добавляем обратный вызов или коллекцию обратных вызовов в список
			добавить: функция() {
				если ( список ) {

					// Если у нас есть память от прошлого запуска, мы должны запустить после добавления
					if (память && !стрельба) {
						индекс стрельбы = список.длина - 1;
						очередь.push(память);
					}

					(функция add(args) {
						jQuery.each(args, function( _, arg) {
							если ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									список.push(аргумент);
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Проверяем рекурсивно
								добавить(аргумент);
							}
						});
					} )(аргументы);

					if (память && !стрельба) {
						огонь();
					}
				}
				верните это;
			},

			// Удаляем обратный вызов из списка
			удалить: функция() {
				jQuery.each(аргументы, функция( _, arg) {
					индекс вар;
					while ( ( index = jQuery.inArray( arg, list, index )) > -1 ) {
						list.splice(индекс, 1);

						// Обработка индексов запуска
						если (индекс <= индекс стрельбы) {
							Индекс стрельбы--;
						}
					}
				});
				верните это;
			},

			// Проверяем, есть ли данный обратный вызов в списке.
			// Если аргумент не указан, возвращается информация о том, есть ли у списка прикрепленные обратные вызовы.
			имеет: функция( fn ) {
				вернуть фн?
					jQuery.inArray(fn, list) > -1:
					список.длина > 0;
			},

			// Удаляем все обратные вызовы из списка
			пусто: функция() {
				если ( список ) {
					список = [];
				}
				верните это;
			},

			// Отключаем .fire и .add
			// Прерываем любые текущие/ожидающие выполнения
			// Очищаем все обратные вызовы и значения
			отключить: функция() {
				заблокировано = очередь = [];
				список = память = "";
				верните это;
			},
			отключено: функция() {
				вернуть! список;
			},

			// Отключить .fire
			// Также отключаем .add, если у нас нет памяти (поскольку это не будет иметь никакого эффекта)
			// Прерываем все ожидающие выполнения
			блокировка: функция() {
				заблокировано = очередь = [];
				if ( !memory && !fireing ) {
					список = память = "";
				}
				верните это;
			},
			заблокировано: функция() {
				возврат !!заблокировано;
			},

			// Вызов всех обратных вызовов с заданным контекстом и аргументами
			fireWith: функция (контекст, аргументы) {
				если ( ! заблокировано ) {
					аргументы = аргументы || [];
					args = [контекст, args.slice? args.slice() : args ];
					очередь.push(аргументы);
					если ( ! стрельба ) {
						огонь();
					}
				}
				верните это;
			},

			// Вызов всех обратных вызовов с заданными аргументами
			огонь: функция() {
				self.fireWith(это, аргументы);
				верните это;
			},

			// Чтобы узнать, вызывались ли обратные вызовы хотя бы один раз
			запущен: функция() {
				вернуться !!уволен;
			}
		};

	вернуть себя;
};


функция Идентичность( v ) {
	вернуть v;
}
функция Thrower( ex ) {
	бросить бывшего;
}

функция принятияЗначение (значение, разрешение, отклонение, noValue) {
	метод вар;

	пытаться {

		// Сначала проверяем наличие аспекта обещания, чтобы обеспечить привилегии синхронного поведения
		if ( значение && isFunction( ( метод = value.promise ) ) ) {
			метод.call(значение).done(решить).fail(отклонить);

		// Другие возможности
		} else if ( значение && isFunction( ( метод = value.then ) ) ) {
			метод.вызов(значение, разрешение, отклонение);

		// Прочее, не связанное с этим
		} еще {

			// Управляйте аргументами `resolve`, позволяя Array#slice привести логическое значение `noValue` к целому числу:
			// * false: [значение].slice(0) => разрешить(значение)
			// * true: [значение].slice(1) =>solve()
			разрешить.применить(не определено, [значение].slice(noValue));
		}

	// Для Promises/A+ конвертируем исключения в отклонения
	// Поскольку jQuery.when не разворачивает thenables, мы можем пропустить дополнительные проверки, появляющиеся в
	// Deferred#then для условного подавления отклонения.
	} поймать (значение) {

		// Поддержка: только Android 4.0
		// Функции строгого режима, вызываемые без .call/.apply, получают контекст глобального объекта
		отклонить.применить(не определено, [значение]);
	}
}

jQuery.extend( {

	Отложенное: функция( func ) {
		вар кортежи = [

				// действие, добавляем прослушиватель, обратные вызовы,
				// ... .then обработчики, индекс аргумента, [конечное состояние]
				[ "уведомить", "прогресс", jQuery.Callbacks("память" ),
					jQuery.Callbacks("память"), 2],
				[ "решить", "готово", jQuery.Callbacks("однажды память"),
					jQuery.Callbacks("однажды память"), 0, "разрешено"],
				[ "отклонить", "провалить", jQuery.Callbacks("однократная память"),
					jQuery.Callbacks("однажды память"), 1, "отклонено"]
			],
			состояние = "ожидание",
			обещание = {
				состояние: функция() {
					возвратное состояние;
				},
				всегда: функция() {
					deferred.done(аргументы).fail(аргументы);
					верните это;
				},
				"поймать": функция( fn ) {
					вернуть обещание.тогда(ноль, фн);
				},

				// Сохраняем канал для обратной совместимости
				труба: функция( /* fnDone, fnFail, fnProgress */) {
					вар fns = аргументы;

					return jQuery.Deferred (функция (newDefer) {
						jQuery.each(кортежи, функция(_i, кортеж) {

							// Сопоставление кортежей (прогресс, выполнено, сбой) с аргументами (сделано, сбой, прогресс)
							var fn = isFunction( fns[tuple[4]]) && fns[tuple[4]];

							// deferred.progress(function() { привязка к newDefer или newDefer.notify })
							// deferred.done(function() { привязка к newDefer или newDefer.resolve })
							// deferred.fail(function() { привязка к newDefer или newDefer.reject })
							отложенный[ кортеж[ 1 ] ]( function() {
								var return = fn && fn.apply(this, аргументы);
								if (возвращено && isFunction(return.promise)) {
									возвращено.обещание()
										.прогресс(newDefer.notify)
										.done(newDefer.resolve)
										.fail(newDefer.reject);
								} еще {
									newDefer[ кортеж[0] + «С» ](
										этот,
										фн? [возвращено]: аргументы
									);
								}
							});
						});
						фнс = ноль;
					} ).обещать();
				},
				затем: функция (onFulfilled, onRejected, onProgress) {
					вар maxDepth = 0;
					functionsolve(глубина, отсрочка, обработчик, специальный) {
						функция возврата() {
							вар это = это,
								аргументы = аргументы,
								mayThrow = функция() {
									Затем вернулся var;

									// Поддержка: Promises/A+ раздел 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Игнорируем попытки двойного разрешения
									if (глубина <maxDepth) {
										возвращаться;
									}

									return = handler.apply( that, args );

									// Поддержка: Promises/A+ раздел 2.3.1
									// https://promisesaplus.com/#point-48
									if (возвращено === deferred.promise()) {
										throw new TypeError("Тогда возможно саморазрешение");
									}

									// Поддержка: Promises/A+ разделы 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Получаем `then` только один раз
									тогда = возвращено &&

										// Поддержка: Promises/A+ раздел 2.3.4
										// https://promisesaplus.com/#point-64
										// Проверяем только объекты и функции на возможность их выполнения
										( typeof возвращен === "объект" ||
											typeof возвращен === "функция") &&
										вернулся.тогда;

									// Обработка возвращенного объекта thenable
									если ( isFunction( тогда ) ) {

										// Специальные процессоры (уведомляют) просто ждут разрешения
										если (специальный) {
											тогда.вызов(
												вернулся,
												разрешить( maxDepth, отложенный, Идентичность, специальный),
												разрешить( maxDepth, отложенный, Thrower, специальный)
											);

										// Обычные процессоры (resolve) также подключаются к прогрессу
										} еще {

											// ...и игнорируем старые значения разрешения
											максимальная глубина++;

											тогда.вызов(
												вернулся,
												разрешить( maxDepth, отложенный, Идентичность, специальный),
												разрешить( maxDepth, отложенный, Thrower, специальный),
												разрешить( maxDepth, deferred, Identity,
													отложенный.notifyWith)
											);
										}

									// Обработка всех остальных возвращаемых значений
									} еще {

										// Только подстановочные обработчики передают контекст
										// и несколько значений (неспецифическое поведение)
										if (обработчик!== Идентичность) {
											это = неопределенно;
											аргументы = [возвращено];
										}

										// Обработка значения(й)
										// Процесс по умолчанию — разрешение
										(специальный || deferred.resolveWith)( that, args);
									}
								},

								// Только обычные процессоры (разрешают) перехватывают и отклоняют исключения
								процесс = специальный?
									может бросить:
									функция() {
										пытаться {
											можетВыбросить();
										} поймать ( е ) {

											если ( jQuery.Deferred.ExceptionHook ) {
												jQuery.Deferred.ExceptionHook( e,
													процесс.ошибка );
											}

											// Поддержка: Promises/A+ раздел 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Игнорируем исключения после разрешения
											if (глубина + 1 >= maxDepth) {

												// Только заменяющие обработчики передают контекст
												// и несколько значений (неспецифическое поведение)
												if (обработчик!== Thrower) {
													это = неопределенно;
													аргументы = [е];
												}

												deferred.rejectWith( that, args);
											}
										}
									};

							// Поддержка: Promises/A+ раздел 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Немедленно повторно разрешите обещания, чтобы избежать ложного отклонения от
							// последующие ошибки
							если ( глубина ) {
								процесс();
							} еще {

								// Вызов дополнительного перехватчика для записи ошибки в случае исключения
								// так как в противном случае он теряется при асинхронном выполнении
								если ( jQuery.Deferred.getErrorHook ) {
									процесс.ошибка = jQuery.Deferred.getErrorHook();

								// Устаревший псевдоним, указанный выше. Хотя название предполагает
								// возвращаем стек, а не экземпляр ошибки, jQuery просто передает
								// напрямую в `console.warn`, так что оба будут работать; экземпляр
								// просто лучше взаимодействует с исходными картами.
								} Еще если ( jQuery.Deferred.getStackHook ) {
									процесс.ошибка = jQuery.Deferred.getStackHook();
								}
								window.setTimeout(процесс);
							}
						};
					}

					return jQuery.Deferred (функция (newDefer) {

						// Progress_handlers.add( ... )
						кортежи[ 0 ][ 3 ].add(
							решать(
								0,
								новыйОтложить,
								isFunction (onProgress)?
									в процессе :
									Личность,
								новыйDefer.notifyWith
							)
						);

						// выполненные_обработчики.add( ... )
						кортежи[ 1 ][ 3 ].add(
							решать(
								0,
								новыйОтложить,
								isFunction (onFulfilled)?
									onВыполнено:
									Личность
							)
						);

						// отклоненные_обработчики.добавить( ... )
						кортежи[ 2 ][ 3 ].add(
							решать(
								0,
								новыйОтложить,
								isFunction (onRejected)?
									onОтклонено:
									Метатель
							)
						);
					} ).обещать();
				},

				// Получаем обещание для этого отложенного
				// Если указан obj, к объекту добавляется аспект обещания
				обещание: функция (объект) {
					вернуть объект!= ноль? jQuery.extend(объект, обещание): обещание;
				}
			},
			отложенный = {};

		// Добавляем методы, специфичные для списка
		jQuery.each(кортежи, функция(я, кортеж) {
			список вар = кортеж[2],
				stateString = кортеж [5];

			// обещание.прогресс = список.добавить
			// обещание.сделано = список.добавить
			// обещание.fail = список.добавить
			обещание[кортеж[1]] = list.add;

			// Обработка состояния
			если (stateString) {
				список.добавить(
					функция() {

						// состояние = «разрешено» (т.е. выполнено)
						// состояние = "отклонено"
						состояние = строка состояния;
					},

					// отклоненные_обратные вызовы.отключить
					// выполненный_callbacks.disable
					кортежи[ 3 - i ][ 2 ].disable,

					// отклоненные_обработчики.отключить
					// выполненные_обработчики.отключить
					кортежи[ 3 - i ][ 3 ].disable,

					// прогресс_коллбэкс.блокировка
					кортежи[ 0 ][ 2 ].lock,

					// прогресс_обработчики.блокировка
					кортежи[ 0 ][ 3 ].lock
				);
			}

			// прогресс_обработчики.огонь
			// выполненные_обработчики.огонь
			// отклоненные_обработчики.огонь
			list.add(кортеж[3].fire);

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			отложенный[ кортеж[0]] = функция() {
				отложенный[ кортеж[0] + «С» ]( это === отложенный ? неопределенный : это, аргументы );
				верните это;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[tuple[0] + «With»] = list.fireWith;
		});

		// Делаем отложенное обещание
		обещание.обещание(отложено);

		// Вызов данной функции, если она есть
		если ( функция ) {
			func.call( отложено, отложено );
		}

		// Все сделано!
		возврат отложен;
	},

	// Отложенный помощник
	когда: функция (singleValue) {
		вар

			// количество незавершенных подчиненных
			осталось = аргументы.длина,

			// количество необработанных аргументов
			я = оставшееся,

			// данные о подчиненном выполнении
			разрешитьКонтексты = Массив(я),
			solveValues ​​= срез.вызов(аргументы),

			// основной отложенный
			первичный = jQuery.Deferred(),

			// подчиненная фабрика обратных вызовов
			updateFunc = функция (я) {
				возвращаемая функция(значение) {
					solveContexts[я] = это;
					solveValues[i] = аргументы.длина > 1? срез.вызов(аргументы): значение;
					если ( !( --оставшийся )) {
						Primary.resolveWith(solveContexts,solveValues);
					}
				};
			};

		// Одиночные и пустые аргументы принимаются как Promise.resolve
		если (осталось <= 1) {
			принятьValue( SingleValue, Primary.done( updateFunc( i ) ).Resolve, Primary.reject,
				!оставшийся );

			// Используйте .then() для развертывания вторичных элементов затем (см. gh-3000)
			if (primary.state() === "ожидание" ||
				isFunction(solveValues[ i ] &&solveValues[ i ].then )) {

				вернуть первичный.тогда();
			}
		}

		// Несколько аргументов объединяются как элементы массива Promise.all
		в то время как я-- ) {
			принятьValue(solveValues[i], updateFunc(i),primary.reject);
		}

		вернуть первичный.обещание();
	}
});


// Обычно они указывают на ошибку программиста во время разработки,
// предупреждаем о них как можно скорее, а не проглатываем их по умолчанию.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// Если определен `jQuery.Deferred.getErrorHook`, `asyncError` является ошибкой
// захватывается перед асинхронным барьером, чтобы получить первоначальную причину ошибки
// который в противном случае может быть скрыт.
jQuery.Deferred.ExceptionHook = функция (ошибка, asyncError) {

	// Поддержка: только IE 8–9
	// Консоль существует, когда инструменты разработки открыты, что может произойти в любой момент
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "Исключение jQuery.Deferred: " + error.message,
			error.stack, asyncError);
	}
};




jQuery.readyException = функция (ошибка) {
	window.setTimeout(функция() {
		ошибка выброса;
	});
};




// Отложенное использование при готовности DOM
вар ReadyList = jQuery.Deferred();

jQuery.fn.ready = функция( fn ) {

	готовый список
		.то(фн)

		// Обернуть jQuery.readyException в функцию, чтобы поиск
		// происходит во время обработки ошибки вместо обратного вызова
		// Регистрация.
		.catch(функция(ошибка) {
			jQuery.readyException(ошибка);
		});

	верните это;
};

jQuery.extend( {

	// Готов ли DOM к использованию? Установите значение true, как только это произойдет.
	isReady: ложь,

	// Счетчик для отслеживания количества элементов, которые нужно дождаться раньше
	// событие готовности срабатывает. См. трек-6781.
	готовОжидать: 1,

	// Обработка готовности DOM
	готов: функция(подождите) {

		// Прерываем, если есть ожидающие удержания или мы уже готовы
		if (wait === true? --jQuery.readyWait: jQuery.isReady) {
			возвращаться;
		}

		// Помните, что DOM готов
		jQuery.isReady = правда;

		// Если сработало обычное событие DOM Ready, уменьшите его и подождите, если необходимо.
		if (подожди!== true && --jQuery.readyWait > 0) {
			возвращаться;
		}

		// Если есть связанные функции, для выполнения
		ReadyList.resolveWith(документ, [jQuery]);
	}
});

jQuery.ready.then = ReadyList.then;

// Обработчик события готовности и метод самоочистки
функция завершена() {
	document.removeEventListener("DOMContentLoaded", завершено);
	window.removeEventListener("загрузка", завершено);
	jQuery.ready();
}

// Перехватываем случаи, когда вызывается $(document).ready()
// после того, как событие браузера уже произошло.
// Поддержка: только IE <=9–10
// Старый IE иногда слишком рано сигнализирует об «интерактивности»
if ( document.readyState === "завершено" ||
	( document.readyState !== "загрузка" && !document.documentElement.doScroll )) {

	// Обрабатываем его асинхронно, чтобы дать сценариям возможность задержать готовность
	window.setTimeout(jQuery.ready);

} еще {

	// Используем удобный обратный вызов события
	document.addEventListener("DOMContentLoaded", завершено);

	// Альтернатива window.onload, которая всегда будет работать
	window.addEventListener("загрузка", завершено);
}




// Многофункциональный метод для получения и установки значений коллекции
// Значение/я могут быть дополнительно выполнены, если это функция
var access = function(elems, fn, key, value, Chainable,emptyGet, raw) {
	вар я = 0,
		len = элементы.длина,
		объем = ключ == ноль;

	// Устанавливает множество значений
	if ( toType(key ) === "объект" ) {
		цепной = правда;
		для (я в ключе) {
			доступ (элементы, fn, я, ключ [я], правда, пустойGet, сырой);
		}

	// Устанавливает одно значение
	} еще если (значение!== неопределенное) {
		цепной = правда;

		если (!isFunction(значение)) {
			сырой = правда;
		}

		если (массовый) {

			// Массовые операции выполняются со всем набором
			если (сырой) {
				fn.call(элементы, значение);
				фн = ноль;

			// ...кроме случаев выполнения значений функции
			} еще {
				объем = фн;
				fn = функция (элемент, _key, значение) {
					return Bulk.call(jQuery(elem),value);
				};
			}
		}

		если ( fn ) {
			для ( ; я < len; я++ ) {
				фн(
					элементы [i], ключ, необработанный?
						ценить :
						value.call(elems[i], i, fn(elems[i], key))
				);
			}
		}
	}

	если (связываемый) {
		возврат элементов;
	}

	// Получает
	если (массовый) {
		вернуть fn.call(элементы);
	}

	вернуть Лен? fn(elems[0], key): пустойGet;
};


// Соответствует пунктирной строке для верблюдизации
вар rmsPrefix = /^-ms-/,
	rdashAlpha = /-([az])/g;

// Используется CamelCase в качестве обратного вызова для replace()
функция fcamelCase(_all, буква) {
	вернуть письмо.toUpperCase();
}

// Преобразование пунктира в CamelCase; используется модулями CSS и данных
// Поддержка: IE <= 9–11, Edge 12–15
// Microsoft забыла указать префикс своего поставщика (trac-9572)
функция CamelCase(строка) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase);
}
вар AcceptData = функция (владелец) {

	// Принимает только:
	// - Узел
	// - Узел.ELEMENT_NODE
	// - Узел.DOCUMENT_NODE
	// - Объект
	// - Любой
	вернуть владельца.nodeType === 1 || владелец.nodeType === 9 || !(+владелец.типузла);
};




функция Данные() {
	this.expando = jQuery.expando + Data.uid++;
}

Данные.uid = 1;

Данные.прототип = {

	кэш: функция(владелец) {

		// Проверяем, есть ли у объекта-владельца кеш
		значение var = владелец [this.expando];

		// Если нет, создаем его
		если ( !значение ) {
			значение = {};

			// Мы можем принимать данные для неэлементных узлов в современных браузерах,
			// но нам не следует этого делать, см. trac-8335.
			// Всегда возвращаем пустой объект.
			если (принятые данные (владелец)) {

				// Если это узел, который вряд ли будет преобразован в строку или зациклен
				// используем простое присваивание
				если (владелец.nodeType) {
					владелец [this.expando] = значение;

				// В противном случае закрепите его в неперечисляемом свойстве
				// configurable должно иметь значение true, чтобы свойство могло быть
				// удаляется при удалении данных
				} еще {
					Object.defineProperty(владелец, this.expando, {
						ценность: ценность,
						настраиваемый: правда
					});
				}
			}
		}

		возвращаемое значение;
	},
	set: функция(владелец, данные, значение) {
		вар реквизит,
			кэш = this.cache(владелец);

		// Обработка: [владелец, ключ, значение] args
		// Всегда используйте ключ CamelCase (gh-2257)
		if ( typeof data === "строка" ) {
			кэш [camelCase (данные)] = значение;

		// Обработка: [владелец, {свойства}] аргументы
		} еще {

			// Копируем свойства одно за другим в объект кэша
			for (реквизит в данных) {
				кэш [camelCase (подпорка)] = данные [подпорка];
			}
		}
		возврат кэша;
	},
	получить: функция (владелец, ключ) {
		ключ возврата === не определено?
			this.cache(владелец):

			// Всегда используйте ключ CamelCase (gh-2257)
			владелец[ this.expando ] && владелец[ this.expando ][camelCase(key) ];
	},
	доступ: функция (владелец, ключ, значение) {

		// В случаях, когда:
		//
		// 1. Ключ не указан
		// 2. Строковый ключ указан, но значение не предоставлено
		//
		// Берем путь «чтения» и позволяем методу get определить
		// какое значение возвращать соответственно либо:
		//
		// 1. Весь объект кэша
		// 2. Данные, хранящиеся по ключу
		//
		if (ключ === не определено ||
				( ( ключ && ключ типа === "строка" ) && значение === неопределенное )) {

			вернуть this.get(владелец, ключ);
		}

		// Когда ключ не является строкой или является одновременно ключом и значением
		// указываются, устанавливаются или расширяются (существующие объекты) с помощью:
		//
		// 1. Объект свойств
		// 2. Ключ и значение
		//
		this.set(владелец, ключ, значение);

		// Так как путь "set" может иметь две возможные точки входа
		// возвращаем ожидаемые данные в зависимости от выбранного пути[*]
		возвращаемое значение!== неопределенное? значение: ключ;
	},
	удалить: функция(владелец, ключ) {
		вар я,
			кэш = владелец [this.expando];

		если (кэш === не определено) {
			возвращаться;
		}

		если (ключ!== не определено) {

			// Поддержка массива или строки ключей, разделенных пробелами
			если (Array.isArray(ключ)) {

				// Если ключ представляет собой массив ключей...
				// Мы всегда устанавливаем ключи CamelCase, поэтому удалите это.
				ключ = key.map(camelCase);
			} еще {
				ключ = CamelCase (ключ);

				// Если существует ключ с пробелами, используйте его.
				// В противном случае создайте массив, сопоставив непробельные символы
				ключ = ключ в кеше?
					[ ключ ] :
					(key.match(rnothtmlwhite) || []);
			}

			я = длина ключа;

			в то время как я-- ) {
				удалить кеш[ключ[i]];
			}
		}

		// Удаляем расширение, если данных больше нет
		if (key === undefined || jQuery.isEmptyObject(cache)) {

			// Поддержка: Chrome <=35 – 45
			// Производительность Webkit и Blink снижается при удалении свойств
			// из узлов DOM, поэтому вместо этого установите значение undef
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (ошибка ограничена)
			если (владелец.nodeType) {
				владелец [this.expando] = не определено;
			} еще {
				удалить владельца [this.expando];
			}
		}
	},
	hasData: функция (владелец) {
		var кэш = владелец [this.expando];
		вернуть кеш !== неопределенное && !jQuery.isEmptyObject(кэш);
	}
};
вар dataPriv = новые данные ();

вар dataUser = новые данные ();



// Сводка реализации
//
// 1. Обеспечение поверхностной и семантической совместимости API с веткой 1.9.x.
// 2. Улучшить ремонтопригодность модуля за счет уменьшения объема памяти
// пути к одному механизму.
// 3. Используйте один и тот же механизм для поддержки «частных» и «пользовательских» данных.
// 4. _Никогда_ не раскрывать "частные" данные пользовательскому коду (СЛЕДОВАТЕЛЬНО: удалить _data, _removeData)
// 5. Избегайте раскрытия деталей реализации пользовательских объектов (например, свойств расширения)
// 6. Предоставьте четкий путь для обновления реализации до WeakMap в 2014 году.

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[AZ]/g;

функция getData(данные) {
	если (данные === "истина") {
		вернуть истину;
	}

	если (данные === "ложь") {
		вернуть ложь;
	}

	если (данные === "ноль") {
		вернуть ноль;
	}

	// Преобразование в число только в том случае, если оно не меняет строку
	если (данные === +данные + "" ) {
		вернуть +данные;
	}

	если (rbrace.test(данные)) {
		вернуть JSON.parse(данные);
	}

	возврат данных;
}

функция dataAttr(элемент, ключ, данные) {
	имя переменной;

	// Если внутри ничего не найдено, попытаемся получить что-нибудь
	// данные из атрибута data-* HTML5
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
		данные = elem.getAttribute(имя);

		if ( typeof data === "строка" ) {
			пытаться {
				данные = получить данные (данные);
			} поймать ( е ) {}

			// Убедитесь, что мы установили данные, чтобы они не были изменены позже
			dataUser.set(элемент, ключ, данные);
		} еще {
			данные = не определены;
		}
	}
	возврат данных;
}

jQuery.extend( {
	hasData: функция (элемент) {
		вернуть dataUser.hasData(elem) || dataPriv.hasData(элемент);
	},

	данные: функция (элемент, имя, данные) {
		вернуть dataUser.access(элемент, имя, данные);
	},

	RemoveData: функция (элемент, имя) {
		dataUser.remove(элемент, имя);
	},

	// TODO: Теперь, когда все вызовы _data и _removeData заменены
	// при прямых вызовах методов dataPriv они могут быть признаны устаревшими.
	_data: функция (элемент, имя, данные) {
		вернуть dataPriv.access(элемент, имя, данные);
	},

	_removeData: функция (элемент, имя) {
		dataPriv.remove(элемент, имя);
	}
});

jQuery.fn.extend( {
	данные: функция (ключ, значение) {
		вар я, имя, данные,
			элем = это[ 0 ],
			attrs = элемент && элем.атрибуты;

		// Получает все значения
		если (ключ === не определено) {
			если ( this.length ) {
				данные = dataUser.get(элемент);

				if ( elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs" ) ) {
					я = атрибуты.длина;
					в то время как я-- ) {

						// Поддержка: только IE 11
						// Элементы attrs могут иметь значение null (trac-14894)
						если ( attrs[ я ] ) {
							имя = attrs[я].имя;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = CamelCase(name.slice(5));
								dataAttr(элемент, имя, данные[имя]);
							}
						}
					}
					dataPriv.set(elem, "hasDataAttrs", true);
				}
			}

			возврат данных;
		}

		// Устанавливает несколько значений
		if ( typeof key === "объект" ) {
			верните this.each( function() {
				dataUser.set(это, ключ);
			});
		}

		возврат доступа (это, функция (значение) {
			переменные данные;

			// Вызывающий объект jQuery (соответствует элементу) не пуст
			// (и, следовательно, элемент появляется в this[ 0 ]) и
			// Параметр `value` не был неопределенным. Пустой объект jQuery.
			// приведет к `undefined` для elem = this[ 0 ], что будет
			// выдаем исключение, если сделана попытка чтения кэша данных.
			if ( элемент && значение === неопределенное ) {

				// Попытка получить данные из кеша
				// Ключ всегда будет в CamelCase в Data
				данные = dataUser.get(элемент, ключ);
				если ( данные !== не определено ) {
					возврат данных;
				}

				// Попытка «обнаружить» данные в
				// Пользовательские данные HTML5-* атрибуты
				данные = dataAttr(элемент, ключ);
				если ( данные !== не определено ) {
					возврат данных;
				}

				// Мы очень старались, но данных не существует.
				возвращаться;
			}

			// Устанавливаем данные...
			this.each( function() {

				// Мы всегда сохраняем ключ CamelCased
				dataUser.set( это, ключ, значение);
			});
		}, ноль, значение, аргументы.длина > 1, ноль, правда );
	},

	удалитьДанные: функция (ключ) {
		верните this.each( function() {
			dataUser.remove(это, ключ);
		});
	}
});


jQuery.extend( {
	очередь: функция (элемент, тип, данные) {
		очередь вар;

		если ( элем ) {
			тип = (тип || "fx" ) + "очередь";
			очередь = dataPriv.get(элемент, тип);

			// Ускоряем удаление из очереди за счет быстрого выхода, если это просто поиск
			если (данные) {
				if ( !queue || Array.isArray(данные) ) {
					очередь = dataPriv.access(elem, type, jQuery.makeArray(data));
				} еще {
					очередь.push(данные);
				}
			}
			обратная очередь || [];
		}
	},

	удаление из очереди: функция (элемент, тип) {
		тип = тип || "FX";

		очередь вар = jQuery.queue(элемент, тип),
			startLength = очередь.длина,
			фн = очередь.сдвиг(),
			хуки = jQuery._queueHooks(элемент, тип),
			следующий = функция() {
				jQuery.dequeue(элемент, тип);
			};

		// Если очередь FX исключена из очереди, всегда удаляйте индикатор прогресса
		if ( fn === "в процессе") {
			fn = очередь.сдвиг();
			началодлины--;
		}

		если ( fn ) {

			// Добавляем индикатор прогресса, чтобы предотвратить попадание в очередь FX
			// автоматически исключено из очереди
			если (тип === "fx" ) {
				очередь.unshift("в процессе");
			}

			// Очищаем последнюю функцию остановки очереди
			удалить хуки.стоп;
			fn.call(элемент, следующий, крючки);
		}

		if (!startLength && крючки) {
			хуки.пустой.огонь();
		}
	},

	// Не публично — сгенерируйте объект очередиHooks или верните текущий
	_queueHooks: функция (элемент, тип) {
		ключ var = тип + «queueHooks»;
		вернуть dataPriv.get(элемент, ключ) || dataPriv.access( элемент, ключ, {
			пусто: jQuery.Callbacks( "однажды память").add( function() {
				dataPriv.remove(elem, [тип + «очередь», ключ]);
			} )
		});
	}
});

jQuery.fn.extend( {
	очередь: функция(тип, данные) {
		вар сеттер = 2;

		if ( typeof type !== "строка" ) {
			данные = тип;
			тип = "FX";
			сеттер--;
		}

		если (аргументы.длина <сеттер) {
			вернуть jQuery.queue(this[0], type);
		}

		возвращаемые данные === не определены?
			этот :
			this.each( function() {
				вар очередь = jQuery.queue(это, тип, данные);

				// Обеспечиваем перехват для этой очереди
				jQuery._queueHooks(это, тип);

				if ( type === "fx" && очередь[ 0 ] !== "inprogress" ) {
					jQuery.dequeue(это, тип);
				}
			});
	},
	удаление из очереди: функция(тип) {
		верните this.each( function() {
			jQuery.dequeue(это, тип);
		});
	},
	ClearQueue: функция (тип) {
		return this.queue( type || "fx", [] );
	},

	// Получаем разрешение промиса при появлении очередей определенного типа
	// очищаются (тип по умолчанию — fx)
	обещание: функция (тип, объект) {
		вар ТМП,
			количество = 1,
			отложить = jQuery.Deferred(),
			элементы = это,
			я = эта.длина,
			разрешить = функция() {
				если ( !( --count )) {
					defer.resolveWith(элементы, [элементы]);
				}
			};

		if ( typeof type !== "строка" ) {
			объект = тип;
			тип = неопределенный;
		}
		тип = тип || "FX";

		в то время как я-- ) {
			tmp = dataPriv.get( elements[i], type + "queueHooks");
			если ( tmp && tmp.empty ) {
				считать++;
				tmp.empty.add(разрешить);
			}
		}
		решать();
		вернуть defer.promise(obj);
	}
});
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([az%]*)$", "i" );


var cssExpand = [ «Сверху», «Справа», «Снизу», «Слева»];

вар documentElement = document.documentElement;



	вар isAttached = функция (элемент) {
			return jQuery.contains(elem.ownerDocument, elem);
		},
		составлен = {составлен: правда};

	// Поддержка: только IE 9–11+, Edge 12–18+, iOS 10.0–10.2.
	// Проверяем вложение через границы теневого DOM, если это возможно (gh-3504)
	// Поддержка: только iOS 10.0-10.2
	// Ранние версии iOS 10 поддерживают `attachShadow`, но не `getRootNode`,
	// приводит к ошибкам. Нам нужно проверить `getRootNode`.
	если ( documentElement.getRootNode ) {
		isAttached = функция (элемент) {
			return jQuery.contains(elem.ownerDocument, elem) ||
				elem.getRootNode(составлен) === elem.ownerDocument;
		};
	}
вар isHiddenWithinTree = функция (элем, эль) {

		// isHiddenWithinTree можно вызвать из функции jQuery#filter;
		// в этом случае элемент будет вторым аргументом
		элем = эл || элем;

		// Встроенный стиль превосходит все
		return elem.style.display === "нет" ||
			elem.style.display === "" &&

			// В противном случае проверяем вычисленный стиль
			// Поддержка: Firefox <=43 - 45
			// Отключенные элементы могут иметь вычисленное значение display: none, поэтому сначала убедитесь, что elem
			// в документе.
			isAttached( элемент ) &&

			jQuery.css(elem, «отображение») === «нет»;
	};



функция корректировкиCSS(elem, prop, valueParts, tween) {
	вар скорректирован, масштаб,
		максИтерации = 20,
		текущее значение = анимация?
			функция() {
				вернуть твин.cur();
			} :
			функция() {
				return jQuery.css(elem, prop, "");
			},
		начальное = текущееЗначение(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[prop] ? "" : "px" ),

		// Вычисление начального значения необходимо для потенциальных несоответствий единиц измерения.
		InitialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec(jQuery.css(elem, prop));

	if ( InitialInUnit && InitialInUnit[ 3 ] !== единица измерения ) {

		// Поддержка: Firefox <=54
		// Уменьшите вдвое целевое значение итерации, чтобы предотвратить влияние верхних границ CSS (gh-2144)
		начальный = начальный / 2;

		// Единицы доверия, о которых сообщает jQuery.css
		единица = единица || начальныйInUnit[3];

		// Итеративно аппроксимируем от ненулевой начальной точки
		начальныйInUnit = + начальный || 1;

		в то время как ( maxIterations-- ) {

			// Оцениваем и обновляем наше лучшее предположение (удвоение предположений, которые обнуляются).
			// Завершаем, если шкала равна или пересекает 1 (что делает результат старый*новый продукт неположительным).
			jQuery.style(elem, prop, InitialInUnit + unit);
			if ( ( 1 - масштаб ) * ( 1 - ( масштаб = currentValue() / начальный || 0,5 ) ) <= 0 ) {
				МаксИтерации = 0;
			}
			начальныйInUnit = начальныйInUnit / масштаб;

		}

		начальныйInUnit = начальныйInUnit * 2;
		jQuery.style(elem, prop, InitialInUnit + unit);

		// Обязательно обновим свойства анимации позже
		valueParts = valueParts || [];
	}

	если (значениеЧасти) {
		начальныйInUnit = + начальныйInUnit || +начальный || 0;

		// Применяем относительное смещение (+=/-=), если указано
		скорректировано = valueParts[1]?
			InitialInUnit + (valueParts[1] + 1) * valueParts[2]:
			+valueParts[ 2 ];
		если ( твин ) {
			твин.единица = единица измерения;
			tween.start = InitialInUnit;
			tween.end = скорректировано;
		}
	}
	возврат скорректирован;
}


вар defaultDisplayMap = {};

функция getDefaultDisplay(элемент) {
	вар температура,
		документ = элемент.владелецДокумент,
		имя_узла = имя_элемента.имя_узла,
		дисплей = defaultDisplayMap[имя узла];

	если (показать) {
		возврат дисплея;
	}

	temp = doc.body.appendChild(doc.createElement(nodeName));
	display = jQuery.css(temp, «дисплей»);

	temp.parentNode.removeChild(временно);

	если (дисплей === "нет") {
		дисплей = «блокировать»;
	}
	defaultDisplayMap[nodeName] = отображение;

	возврат дисплея;
}

функция showHide(элементы, шоу) {
	отображение вар, элем,
		значения = [],
		индекс = 0,
		длина = elements.length;

	// Определяем новое отображаемое значение для элементов, которые необходимо изменить
	for ( ; индекс < длина; индекс++ ) {
		элем = элементы [индекс];
		если (!elem.style) {
			продолжать;
		}

		дисплей = элемент.стиль.дисплей;
		если ( показать ) {

			// Поскольку мы принудительно видим элементы, скрытые каскадом, немедленная (и медленная)
			// проверка требуется в этом первом цикле, если только у нас нет непустого отображаемого значения (либо
			// встроенный или скоро будет восстановлен)
			если (дисплей === "нет") {
				значения[индекс] = dataPriv.get(elem, «отображение») || нулевой;
				если ( !values[индекс]) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree(elem) ) {
				значения [индекс] = getDefaultDisplay (элемент);
			}
		} еще {
			if ( display !== "none") {
				значения [индекс] = «нет»;

				// Запоминаем, что мы перезаписываем
				dataPriv.set(элемент, «дисплей», дисплей);
			}
		}
	}

	// Устанавливаем отображение элементов во втором цикле, чтобы избежать постоянного переформатирования
	for (индекс = 0; индекс <длина; индекс++) {
		если (значения[индекс]!= ноль) {
			элементы[индекс].style.display = значения[индекс];
		}
	}

	возвратные элементы;
}

jQuery.fn.extend( {
	показать: функция() {
		вернуть showHide(это, правда);
	},
	скрыть: функция() {
		вернуть showHide(это);
	},
	переключить: функция (состояние) {
		if ( typeof state === "boolean" ) {
			вернуть состояние? this.show() : this.hide();
		}

		верните this.each( function() {
			если (isHiddenWithinTree(это)) {
				jQuery(это).show();
			} еще {
				jQuery(это).hide();
			}
		});
	}
});
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([az][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



(функция() {
	фрагмент var = document.createDocumentFragment(),
		div = фрагмент.appendChild( document.createElement( "div" )),
		input = document.createElement("вход");

	// Поддержка: только Android 4.0–4.3
	// Проверка состояния потеряна, если имя установлено (trac-11217)
	// Поддержка: веб-приложения Windows (WWA)
	// `name` и `type` должны использовать .setAttribute для WWA (trac-14901)
	input.setAttribute("тип", "радио");
	input.setAttribute("проверено", "проверено");
	input.setAttribute("имя", "т");

	div.appendChild(вход);

	// Поддержка: только Android <= 4.1
	// Старый WebKit неправильно клонирует проверенное состояние во фрагментах
	support.checkClone = div.cloneNode(истина).cloneNode(истина).lastChild.checked;

	// Поддержка: только IE <= 11
	// Убедитесь, что текстовая область (и флажок) defaultValue правильно клонированы
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode(истина).lastChild.defaultValue;

	// Поддержка: только IE <=9
	// IE <=9 заменяет теги <option> их содержимым при вставке за пределы
	// элемент выбора.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// Нам нужно закрыть эти теги для поддержки XHTML (trac-13200)
вар WrapMap = {

	// Синтаксические анализаторы XHTML не вставляют элементы в
	// так же, как это делают парсеры тегов. Поэтому мы не можем сократить
	// это достигается путем опускания <tbody> или других обязательных элементов.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

WrapMap.tbody = WrapMap.tfoot = WrapMap.colgroup = WrapMap.caption = WrapMap.thead;
WrapMap.th = WrapMap.td;

// Поддержка: только IE <=9
если (!support.option) {
	WrapMap.optgroup = WrapMap.option = [ 1, "<select Multiple='multiple'>", "</select>" ];
}


функция getAll(контекст, тег) {

	// Поддержка: только IE <=9–11
	// Используйте typeof, чтобы избежать вызова метода с нулевым аргументом для объектов хоста (trac-15151)
	вар рет;

	if ( typeof context.getElementsByTagName !== "не определено" ) {
		ret = context.getElementsByTagName(тег || "*");

	} else if ( typeof context.querySelectorAll !== "не определено" ) {
		ret = context.querySelectorAll(тег || "*");

	} еще {
		Рет = [];
	}

	if ( тег === неопределенно || тег && имя_узла (контекст, тег) ) {
		return jQuery.merge([контекст], ret);
	}

	вернуть возврат;
}


// Отмечаем скрипты как уже оцененные
функция setGlobalEval(elems, refElements) {
	вар я = 0,
		l = элементы.длина;

	для ( ; я < l; я++ ) {
		dataPriv.set(
			элементы [ я ],
			"глобальныйEval",
			!refElements || dataPriv.get( refElements[i], «globalEval»)
		);
	}
}


var rhtml = /<|&#?\w+;/;

функция buildFragment(элементы, контекст, сценарии, выбор, игнорируется) {
	вар элем, tmp, тег, обертка, прикрепленный, j,
		фрагмент = context.createDocumentFragment(),
		узлы = [],
		я = 0,
		l = элементы.длина;

	для ( ; я < l; я++ ) {
		элемент = элементы [я];

		если ( элем || элем === 0 ) {

			// Добавляем узлы напрямую
			if ( toType(elem ) === "объект" ) {

				// Поддержка: только Android <= 4.0, только PhantomJS 1
				// push.apply(_, arraylike) вызывает древний WebKit
				jQuery.merge(узлы, elem.nodeType? [elem]: elem);

			// Преобразуем не-html в текстовый узел
			} else if ( !rhtml.test(elem ) ) {
				nodes.push(context.createTextNode(elem));

			// Конвертируем html в узлы DOM
			} еще {
				тмп = тмп || фрагмент.appendChild( context.createElement( "div" ));

				// Десериализация стандартного представления
				tag = (rtagName.exec(elem) || [ "", "" ] )[ 1 ].toLowerCase();
				обертка = обертка[тег] || оберткаMap._default;
				tmp.innerHTML = Wrap[ 1 ] + jQuery.htmlPrefilter(elem) + Wrap[ 2 ];

				// Спускаемся через обертки к нужному контенту
				j = обернуть [0];
				в то время как ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Поддержка: только Android <= 4.0, только PhantomJS 1
				// push.apply(_, arraylike) вызывает древний WebKit
				jQuery.merge(узлы, tmp.childNodes);

				// Помните о контейнере верхнего уровня
				tmp = фрагмент.FirstChild;

				// Убедитесь, что созданные узлы являются осиротевшими (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Удалить обертку из фрагмента
	фрагмент.textContent = "";

	я = 0;
	while ( ( elem = узлы [ i++ ] ) ) {

		// Пропускаем элементы, уже находящиеся в коллекции контекстов (trac-4087)
		if (выбор && jQuery.inArray(elem, выбор) > -1) {
			если (проигнорировано) {
				ignore.push(элемент);
			}
			продолжать;
		}

		присоединен = isAttached(элемент);

		// Добавляем к фрагменту
		tmp = getAll(ragment.appendChild(elem), "script");

		// Сохраняем историю оценки скрипта
		если ( прилагается ) {
			setGlobalEval(tmp);
		}

		// Захват исполняемых файлов
		если (скрипты) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test(elem.type || "" )) {
					scripts.push(элемент);
				}
			}
		}
	}

	вернуть фрагмент;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

функция returnTrue() {
	вернуть истину;
}

функция returnFalse() {
	вернуть ложь;
}

функция on(elem, типы, селектор, данные, fn, один) {
	вар origFn, тип;

	// Типы могут быть картой типов/обработчиков
	if ( typeof типы === "объект" ) {

		// (типы-Объект, селектор, данные)
		if ( селектор типа !== "строка" ) {

			// (типы-Объект, данные)
			данные = данные || селектор;
			селектор = не определено;
		}
		for (введите типы) {
			on(элемент, тип, селектор, данные, типы[тип], один);
		}
		вернуть элемент;
	}

	if ( data == null && fn == null ) {

		// (типы, фн)
		фн = селектор;
		данные = селектор = не определено;
	} еще если ( fn == null ) {
		if ( селектор typeof === "строка" ) {

			// (типы, селектор, fn)
			фн = данные;
			данные = не определены;
		} еще {

			// (типы, данные, fn)
			фн = данные;
			данные = селектор;
			селектор = не определено;
		}
	}
	если ( fn === ложь ) {
		фн = возвратложь;
	} иначе, если ( !fn ) {
		вернуть элемент;
	}

	если ( один === 1 ) {
		исходноеFn = fn;
		fn = функция (событие) {

			// Можно использовать пустой набор, поскольку событие содержит информацию
			jQuery().off(событие);
			вернуть origFn.apply(это, аргументы);
		};

		// Используйте тот же идентификатор, чтобы вызывающий абонент мог удалить его с помощью origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add(this, типы, fn, данные, селектор);
	});
}

/*
 * Вспомогательные функции для управления событиями — не являются частью общедоступного интерфейса.
 * Поддержка библиотеки addEvent Дина Эдвардса для многих идей.
 */
jQuery.event = {

	Глобальный: {},

	добавить: функция (элемент, типы, обработчик, данные, селектор) {

		вар handleObjIn, eventHandle, tmp,
			события, т, handleObj,
			специальные, обработчики, тип, пространства имен, origType,
			elemData = dataPriv.get(elem);

		// Прикрепляем события только к объектам, которые принимают данные
		если (!acceptData(elem)) {
			возвращаться;
		}

		// Вызывающий объект может передать объект пользовательских данных вместо обработчика
		если (обработчик.обработчик) {
			handleObjIn = обработчик;
			обработчик = handleObjIn.handler;
			селектор = handleObjIn.selector;
		}

		// Убедитесь, что недопустимые селекторы выдают исключения во время подключения
		// Оценка документа documentElement в случае, если elem не является узлом (например, документ)
		если (селектор) {
			jQuery.find.matchesSelector(documentElement, селектор);
		}

		// Убедитесь, что обработчик имеет уникальный идентификатор, который будет использоваться для его последующего поиска/удаления
		если (!handler.guid) {
			handler.guid = jQuery.guid++;
		}

		// Инициализируем структуру событий элемента и основной обработчик, если это первый
		если ( !( события = elemData.events )) {
			события = elemData.events = Object.create(null);
		}
		если ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = функция (е) {

				// Отбрасываем второе событие jQuery.event.trigger() и
				// когда событие вызывается после выгрузки страницы
				return typeof jQuery !== "неопределено" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply(элемент, аргументы): неопределенно;
			};
		}

		// Обработка нескольких событий, разделенных пробелом
		типы = ( типы || "" ).match( rnothtmlwhite ) || [ "" ];
		т = типы.длина;
		в то время как ( т-- ) {
			tmp = rtypenamespace.exec(types[t]) || [];
			тип = origType = tmp[1];
			пространства имен = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Должен* быть тип, никаких обработчиков, относящихся только к пространству имен
			если ( !тип ) {
				продолжать;
			}

			// Если событие меняет свой тип, используйте специальные обработчики событий для измененного типа
			специальный = jQuery.event.special[тип] || {};

			// Если селектор определен, определите тип API специального события, в противном случае заданный тип
			тип = (селектор? Special.delegateType: Special.bindType) || тип;

			// Специальное обновление на основе нового типа сброса
			специальный = jQuery.event.special[тип] || {};

			// handleObj передается всем обработчикам событий
			handleObj = jQuery.extend( {
				тип: тип,
				origType: origType,
				данные: данные,
				обработчик: обработчик,
				руководство: handler.guid,
				селектор: селектор,
				NeedsContext: селектор && jQuery.expr.match.needsContext.test(селектор),
				пространство имен: namespaces.join( "." )
			}, handleObjIn );

			// Инициализируем очередь обработчиков событий, если мы первые
			if ( !( обработчики = события[тип] ) ) {
				обработчики = события[тип] = [];
				обработчики.delegateCount = 0;

				// Используйте addEventListener только в том случае, если обработчик специальных событий возвращает false
				если ( !special.setup ||
					Special.setup.call(elem, data, namespaces, eventHandle) === false) {

					если (elem.addEventListener) {
						elem.addEventListener(тип, eventHandle);
					}
				}
			}

			если (специальный.добавить) {
				Special.add.call(elem, handleObj);

				если (!handleObj.handler.guid) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Добавляем в список обработчиков элемента делегаты впереди
			если (селектор) {
				handlers.splice(handlers.delegateCount++, 0, handleObj);
			} еще {
				handlers.push(handleObj);
			}

			// Отслеживаем, какие события когда-либо использовались, для оптимизации событий
			jQuery.event.global[тип] = true;
		}

	},

	// Отделяем событие или набор событий от элемента
	удалить: функция (элемент, типы, обработчик, селектор, MappedTypes) {

		вар j, origCount, tmp,
			события, т, handleObj,
			специальные, обработчики, тип, пространства имен, origType,
			elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

		if ( !elemData || !(events = elemData.events) ) {
			возвращаться;
		}

		// Один раз для каждого type.namespace в типах; тип может быть опущен
		типы = ( типы || "" ).match( rnothtmlwhite ) || [ "" ];
		т = типы.длина;
		в то время как ( т-- ) {
			tmp = rtypenamespace.exec(types[t]) || [];
			тип = origType = tmp[1];
			пространства имен = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Отвязываем все события (в этом пространстве имен, если они предусмотрены) для элемента
			если ( !тип ) {
				for (введите события) {
					jQuery.event.remove(elem, type + типы[t], обработчик, селектор, true);
				}
				продолжать;
			}

			специальный = jQuery.event.special[тип] || {};
			тип = (селектор? Special.delegateType: Special.bindType) || тип;
			обработчики = события[тип] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Удаляем соответствующие события
			origCount = j = handlers.length;
			в то время как ( j-- ) {
				handleObj = обработчики [j];

				if ( (mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace )) &&
					( !селектор || селектор === handleObj.selector ||
						селектор === "**" && handleObj.selector ) ) {
					handlers.splice(j, 1);

					если ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					если (специальный.удалить) {
						Special.remove.call(elem, handleObj);
					}
				}
			}

			// Удаляем общий обработчик событий, если мы что-то удалили и обработчиков больше не существует
			// (избегает возможности бесконечной рекурсии при удалении специальных обработчиков событий)
			if ( origCount && !handlers.length ) {
				если ( !special.teardown ||
					Special.teardown.call(elem, namespaces, elemData.handle) === false) {

					jQuery.removeEvent(elem, type, elemData.handle);
				}

				удалить события[тип];
			}
		}

		// Удаляем данные и расширение, если оно больше не используется
		если ( jQuery.isEmptyObject(события) ) {
			dataPriv.remove(elem, "обрабатывать события");
		}
	},

	отправка: функция (nativeEvent) {

		вар я, j, ret, соответствует, handleObj, handlerQueue,
			args = новый массив (аргументы.длина),

			// Создание записываемого jQuery.Event из собственного объекта события
			событие = jQuery.event.fix(nativeEvent),

			обработчики = (
				dataPriv.get(this, "события") || Object.create(ноль)
			)[ тип события ] || [],
			специальный = jQuery.event.special[ event.type ] || {};

		// Используйте фиксированное jQuery.Event вместо собственного события (только для чтения)
		args[0] = событие;

		for ( я = 1; я <аргументы.длина; я++) {
			args[i] = аргументы[i];
		}

		event.delegateTarget = это;

		// Вызываем хук preDispatch для отображаемого типа и при необходимости даем ему возможность выйти из строя
		if (special.preDispatch && Special.preDispatch.call(this, event) === false) {
			возвращаться;
		}

		// Определяем обработчики
		handlerQueue = jQuery.event.handlers.call(это, событие, обработчики);

		// Сначала запускаем делегаты; они могут захотеть остановить распространение под нами
		я = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Если событие находится в пространстве имен, то каждый обработчик вызывается только в том случае, если он
				// специально универсальный или его пространства имен являются надмножеством событий.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test(handleObj.namespace) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					если (рет!== не определено) {
						if ( ( event.result = ret ) === false ) {
							событие.preventDefault();
							событие.stopPropagation();
						}
					}
				}
			}
		}

		// Вызов хука postDispatch для сопоставленного типа
		если (special.postDispatch) {
			Special.postDispatch.call(это, событие);
		}

		вернуть событие.результат;
	},

	обработчики: функция(событие, обработчики) {
		вар я, handleObj, сел, matchedHandlers, matchedSelectors,
			обработчикОчередь = [],
			DelegateCount = handlers.delegateCount,
			кур = event.target;

		// Находим обработчики делегатов
		если ( делегатCount &&

			// Поддержка: IE <=9
			// Деревья экземпляров <use> SVG типа «черная дыра» (trac-13180)
			Cur.nodeType &&

			// Поддержка: Firefox <=42
			// Подавление нарушающих спецификацию щелчков, указывающих на неосновную кнопку указателя (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Поддержка: только IE 11
			// ...но не "щелчки" клавиш со стрелками радиовходов, которые могут иметь `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 )) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Не проверять неэлементы (trac-13208)
				// Не обрабатывать клики по отключенным элементам (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true )) {
					matchedHandlers = [];
					matchedSelectors = {};
					для (я = 0; я <delegateCount; я++) {
						handleObj = обработчики [я];

						// Не конфликтовать со свойствами Object.prototype (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === не определено ) {
							matchedSelectors[sel] = handleObj.needsContext?
								jQuery(sel, this).index(cur) > -1:
								jQuery.find(sel, this, null, [cur]).length;
						}
						если ( matchedSelectors[sel]) {
							matchedHandlers.push(handleObj);
						}
					}
					если ( matchedHandlers.length ) {
						handlerQueue.push( {elem: cur, handlers: matchedHandlers });
					}
				}
			}
		}

		// Добавляем оставшиеся (связанные напрямую) обработчики
		кур = это;
		если (delegateCount <handlers.length) {
			handlerQueue.push( {elem: cur, handlers: handlers.slice(delegateCount) });
		}

		вернуть обработчик очереди;
	},

	addProp: функция(имя, крючок) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			перечислимое: правда,
			настраивается: правда,

			получить: isFunction (крючок)?
				функция() {
					если ( this.originalEvent ) {
						возвратный крючок (this.originalEvent);
					}
				} :
				функция() {
					если ( this.originalEvent ) {
						вернуть this.originalEvent[имя];
					}
				},

			установить: функция(значение) {
				Object.defineProperty( это, имя, {
					перечислимое: правда,
					настраивается: правда,
					записываемый: правда,
					ценность: ценность
				});
			}
		});
	},

	исправлено: функция (originalEvent) {
		вернуть originalEvent[jQuery.expando]?
			оригинальное событие:
			новый jQuery.Event(originalEvent);
	},

	особенный: {
		нагрузка: {

			// Предотвращаем передачу триггерных событий image.load в window.load
			нетбаббл: правда
		},
		нажмите: {

			// Используйте собственное событие, чтобы обеспечить правильное состояние проверяемых входных данных
			настройка: функция (данные) {

				// Для взаимной сжимаемости с помощью _default замените доступ `this` на локальную переменную.
				// `|| data` — это мертвый код, предназначенный только для сохранения переменной посредством минимизации.
				вар эль = это || данные;

				// Требуем первый обработчик
				if ( rcheckableType.test(el.type) &&
					el.click && nodeName(el, "input" ) ) {

					// dataPriv.set(el, "клик", ... )
					leverageNative(el, «клик», true);
				}

				// Возвращаем false, чтобы разрешить нормальную обработку вызывающей стороне
				вернуть ложь;
			},
			триггер: функция(данные) {

				// Для взаимной сжимаемости с помощью _default замените доступ `this` на локальную переменную.
				// `|| data` — это мертвый код, предназначенный только для сохранения переменной посредством минимизации.
				вар эль = это || данные;

				// Принудительная настройка перед срабатыванием клика
				if ( rcheckableType.test(el.type) &&
					el.click && nodeName(el, "input" ) ) {

					leverageNative(el, «клик»);
				}

				// Возвращаем неложное значение, чтобы разрешить нормальное распространение пути события
				вернуть истину;
			},

			// Для обеспечения совместимости между браузерами отключите встроенный метод .click() для ссылок
			// Также предотвратим это, если в данный момент мы находимся внутри стека собственных событий с использованием рычага
			_default: функция (событие) {
				вар цель = event.target;
				вернуть rcheckableType.test(target.type) &&
					target.click && имя_узла(цель, "вход") &&
					dataPriv.get(цель, «клик») ||
					имя_узла(цель, "а");
			}
		},

		перед выгрузкой: {
			postDispatch: функция (событие) {

				// Поддержка: Firefox 20+
				// Firefox не выдает предупреждение, если поле returnValue не установлено.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Обеспечиваем наличие прослушивателя событий, который обрабатывает запускаемые вручную
// синтетические события, прерывающие прогресс до повторного вызова в ответ на
// *родные* события, которые он запускает напрямую, гарантируя, что изменения состояния
// уже произошло до того, как были вызваны другие прослушиватели.
функция рычагаNative(el, type, isSetup) {

	// Отсутствие `isSetup` указывает на вызов триггера, который должен принудительно настроить через jQuery.event.add
	если (!isSetup) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add(el, type, returnTrue);
		}
		возвращаться;
	}

	// Регистрируем контроллер как специальный универсальный обработчик для всех пространств имен событий
	dataPriv.set(эл, тип, ложь);
	jQuery.event.add( эль, тип, {
		пространство имен: ложь,
		обработчик: функция(событие) {
			вар результат,
				сохранено = dataPriv.get(это, тип);

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Прерываем обработку внешнего синтетического события .trigger()ed
				если ( !сохранено ) {

					// Сохраняем аргументы для использования при обработке внутреннего собственного события
					// Всегда будет хотя бы один аргумент (объект события), поэтому этот массив
					// не будет перепутано с остатком объекта захвата.
					сохранено = срез.вызов(аргументы);
					dataPriv.set(это, введите, сохранено);

					// Запускаем собственное событие и фиксируем его результат
					этот тип ]();
					результат = dataPriv.get(это, тип);
					dataPriv.set(это, тип, ложь);

					if (сохранено!== результат) {

						// Отменяем внешнее синтетическое событие
						event.stopImmediatePropagation();
						событие.preventDefault();

						вернуть результат;
					}

				// Если это внутреннее синтетическое событие для события с всплывающим суррогатом
				// (фокус или размытие), предположим, что суррогат уже распространился после срабатывания
				// собственное событие и предотвращаем его повторение здесь.
				// Технически это приводит к неправильному порядку относительно `.trigger()` (в котором
				// пузырьковый суррогат распространяется *после* непузырьковой базы), но это кажется
				// менее плохо, чем дублирование.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					событие.stopPropagation();
				}

			// Если это нативное событие, вызванное выше, теперь все в порядке
			// Запускаем внутреннее синтетическое событие с исходными аргументами
			} еще если (сохранено) {

				// ...и фиксируем результат
				dataPriv.set( это, тип, jQuery.event.trigger(
					сохранено[ 0 ],
					сохраненный.срез( 1 ),
					этот
				) );

				// Прерываем обработку собственного события всеми обработчиками jQuery, разрешая
				// собственные обработчики того же элемента для запуска. По цели это достигается
				// останавливая немедленное распространение только по событию jQuery. Однако,
				// собственное событие повторно обертывается событием jQuery на каждом уровне
				// распространение, поэтому единственный способ остановить его для jQuery — это остановить его на
				// всем через встроенный `stopPropagation()`. Это не проблема для
				// фокус/размытие, которые не всплывают, но также останавливают нажатие на флажки
				// и радио. Мы принимаем это ограничение.
				событие.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	});
}

jQuery.removeEvent = функция (элемент, тип, дескриптор) {

	// Это «если» необходимо для простых объектов
	если ( elem.removeEventListener ) {
		elem.removeEventListener(тип, дескриптор);
	}
};

jQuery.Event = функция (источник, реквизит) {

	// Разрешить создание экземпляра без ключевого слова 'new'
	if ( !( этот экземпляр jQuery.Event )) {
		вернуть новый jQuery.Event(src, props);
	}

	// Объект события
	если ( источник && источник.тип ) {
		this.originalEvent = источник;
		this.type = src.type;

		// События, вызывающие появление документа, могли быть помечены как предотвращенные
		// обработчиком ниже по дереву; отражать правильное значение.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === не определено &&

				// Поддержка: только Android <= 2.3
				src.returnValue === ложь?
			возвратистина:
			возврат Ложь;

		// Создаём целевые свойства
		// Поддержка: только Safari <=6–7
		// Целью не должен быть текстовый узел (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode:
			источник.цель;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.latedTarget;

	// Тип события
	} еще {
		this.type = источник;
	}

	// Помещаем явно предоставленные свойства в объект события
	если ( реквизит ) {
		jQuery.extend(это, реквизит);
	}

	// Создаем временную метку, если у входящего события ее нет
	this.timeStamp = источник && src.timeStamp || Дата.сейчас();

	// Отмечаем как исправленное
	это [jQuery.expando] = правда;
};

// jQuery.Event основан на событиях DOM3, как указано в привязке языка ECMAScript.
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	конструктор: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: ложь,

	предотвратитьПо умолчанию: функция() {
		вар е = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			е.preventDefault();
		}
	},
	стопПропагация: функция() {
		вар е = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			е.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		вар е = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		это.stopPropagation();
	}
};

// Включает все общие реквизиты событий, включая специальные реквизиты KeyEvent и MouseEvent.
jQuery.each( {
	altKey: правда,
	пузыри: правда,
	отменяемый: правда,
	измененоTouches: правда,
	CtrlKey: правда,
	подробность: правда,
	eventPhase: правда,
	метаКей: правда,
	страницаX: правда,
	страницаY: правда,
	ShiftKey: правда,
	мнение: правда,
	"чар": правда,
	код: правда,
	код символа: правда,
	ключ: правда,
	ключевой код: правда,
	кнопка: правда,
	кнопки: правда,
	клиентX: правда,
	клиентY: правда,
	смещениеX: правда,
	смещениеY: правда,
	идентификатор указателя: правда,
	Тип указателя: правда,
	экранX: правда,
	экранY: правда,
	targetTouches: правда,
	toElement: правда,
	трогает: правда,
	что: правда
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", размытие: "focusout" }, function( type, DelegateType ) {

	функция focusMappedHandler(nativeEvent) {
		если ( document.documentMode ) {

			// Поддержка: IE 11+
			// Прикрепляем к документу один обработчик фокуса/фокуса, пока кто-то хочет
			// фокус/размытие. Это связано с тем, что первые синхронны в IE, а вторые
			// являются асинхронными. В других браузерах все эти обработчики вызываются синхронно.

			// `дескриптор` из личных данных уже будет обертывать событие, но нам нужно
			// чтобы изменить здесь `type`.
			var handle = dataPriv.get(this, "handle" ),
				событие = jQuery.event.fix(nativeEvent);
			event.type =nativeEvent.type === "focusin" ? «фокус»: «размытие»;
			event.isSimulated = правда;

			// Сначала обрабатываем фокус в/фокус
			дескриптор (родное событие);

			// ...затем обрабатываем фокус/размытие
			//
			// фокус/размытие не всплывает, а фокус при/выход фокуса появляется; имитировать первое только
			// вызов обработчика на нижнем уровне.
			если ( event.target === event.currentTarget ) {

				// Часть настройки вызывает `leverageNative`, который, в свою очередь, вызывает
				// `jQuery.event.add`, поэтому дескриптор события уже установлен
				// к этому моменту.
				дескриптор (событие);
			}
		} еще {

			// Для браузеров, отличных от IE, прикрепите к документу один обработчик захвата
			// пока кто-то хочет сфокусироваться/сфокусироваться.
			jQuery.event.simulate(delegateType,nativeEvent.target,
				jQuery.event.fix(nativeEvent));
		}
	}

	jQuery.event.special[тип] = {

		// Если возможно, используйте собственное событие, чтобы последовательность размытия/фокуса была правильной
		настройка: функция() {

			вар присоединяется;

			// Требуем первый обработчик
			// dataPriv.set( this, "фокус", ... )
			// dataPriv.set( this, "размытие", ... )
			рычагиNative (это, тип, правда);

			если ( document.documentMode ) {

				// Поддержка: IE 9–11+
				// Мы используем один и тот же собственный обработчик для фокусировки и фокусировки (а также для фокусировки и размытия)
				// поэтому нам нужно согласовать части настройки и демонтажа между этими событиями.
				// Используйте `delegateType` в качестве ключа, поскольку `type` уже используется `leverageNative`.
				Attaches = dataPriv.get(this, DelegateType);
				если ( !прикрепляется ) {
					this.addEventListener(memberType, focusMappedHandler);
				}
				dataPriv.set( this, DelegateType, (прикрепляет || 0) + 1);
			} еще {

				// Возвращаем false, чтобы разрешить нормальную обработку вызывающей стороне
				вернуть ложь;
			}
		},
		триггер: функция() {

			// Принудительная установка перед триггером
			рычаг Native (это, тип);

			// Возвращаем неложное значение, чтобы разрешить нормальное распространение пути события
			вернуть истину;
		},

		демонтаж: функция() {
			вар присоединяется;

			если ( document.documentMode ) {
				прикрепляет = dataPriv.get (это, тип делегата) - 1;
				если ( !прикрепляется ) {
					this.removeEventListener(memberType, focusMappedHandler);
					dataPriv.remove(это, Тип делегата);
				} еще {
					dataPriv.set(this, DelegateType, Attaches);
				}
			} еще {

				// Возвращаем false, чтобы указать, что следует применить стандартное удаление
				вернуть ложь;
			}
		},

		// Подавить собственный фокус или размытие, если мы в данный момент находимся внутри
		// стек собственных событий с использованием рычага
		_default: функция (событие) {
			вернуть dataPriv.get( event.target, type );
		},

		Тип делегата: Тип делегата
	};

	// Поддержка: Firefox <=44
	// Firefox не имеет событий focus(in | out)
	// Связанный билет - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Поддержка: Chrome <=48–49, Safari <=9,0–9,1
	// события focus(in | out) срабатывают после событий фокуса и размытия,
	// это нарушение спецификации - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Связанный билет - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Поддержка: IE 9–11+
	// Чтобы сохранить относительный порядок событий focusin/focus и focusout/blur, гарантированный в ветке 3.x,
	// прикрепляем один обработчик для обоих событий в IE.
	jQuery.event.special[delegateType] = {
		настройка: функция() {

			// Дескриптор: обычные узлы (через `this.ownerDocument`), окно
			// (через `this.document`) и документ (через `this`).
			вар документ = this.ownerDocument || этот.документ || этот,
				dataHolder = document.documentMode? это: док,
				Attaches = dataPriv.get(dataHolder, DelegateType);

			// Поддержка: IE 9–11+
			// Мы используем один и тот же собственный обработчик для фокусировки и фокусировки (а также для фокусировки и размытия)
			// поэтому нам нужно согласовать части настройки и демонтажа между этими событиями.
			// Используйте `delegateType` в качестве ключа, поскольку `type` уже используется `leverageNative`.
			если ( !прикрепляется ) {
				если ( document.documentMode ) {
					this.addEventListener(memberType, focusMappedHandler);
				} еще {
					doc.addEventListener(тип, focusMappedHandler, true);
				}
			}
			dataPriv.set( dataHolder, DelegateType, (присоединяется || 0) + 1);
		},
		демонтаж: функция() {
			вар документ = this.ownerDocument || этот.документ || этот,
				dataHolder = document.documentMode? это: док,
				Attaches = dataPriv.get(dataHolder, DelegateType) - 1;

			если ( !прикрепляется ) {
				если ( document.documentMode ) {
					this.removeEventListener(memberType, focusMappedHandler);
				} еще {
					doc.removeEventListener(тип, focusMappedHandler, true);
				}
				dataPriv.remove( dataHolder, DelegateType );
			} еще {
				dataPriv.set( dataHolder, DelegateType, Attaches);
			}
		}
	};
});

// Создание событий ввода/выключения мыши с использованием проверок наведения/выключения мыши и времени события
// чтобы делегирование событий работало в jQuery.
// Делаем то же самое для pointerenter/pointerleave и pointerover/pointerout
//
// Поддержка: только Safari 7
// Safari слишком часто отправляет mouseenter; видеть:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// для описания ошибки (она существовала и в старых версиях Chrome).
jQuery.each( {
	mouseenter: "наведение курсора мыши",
	mouseleave: "mouseout",
	pointerenter: "указатель",
	pointerleave: "pointerout"
}, функция(оригинал, исправление) {
	jQuery.event.special[ ориг ] = {
		Тип делегата: исправление,
		тип привязки: исправить,

		дескриптор: функция (событие) {
			вар Рет,
				цель = это,
				связанный = событие.связанныйTarget,
				handleObj = event.handleObj;

			// Для mouseenter/leave вызовите обработчик, если связанный объект находится за пределами цели.
			// Примечание: связанный объект отсутствует, если мышь покинула окно браузера или вошла в него
			if ( !родственного || (связанного !== цель && !jQuery.contains(цель, связанного) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply(это, аргументы);
				event.type = исправить;
			}
			вернуть возврат;
		}
	};
});

jQuery.fn.extend( {

	on: функция (типы, селектор, данные, fn) {
		return on( this, типы, селектор, данные, fn);
	},
	один: функция (типы, селектор, данные, fn) {
		return on(this, типы, селектор, данные, fn, 1);
	},
	выключено: функция (типы, селектор, fn) {
		вар handleObj, тип;
		if ( типы && типы.preventDefault && типы.handleObj ) {

			// (событие) отправлено jQuery.Event
			handleObj = типы.handleObj;
			jQuery(types.delegateTarget).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace:
					handleObj.origType,
				handleObj.селектор,
				handleObj.handler
			);
			верните это;
		}
		if ( typeof типы === "объект" ) {

			// (объект типов [, селектор])
			for (введите типы) {
				this.off(тип, селектор, типы[тип]);
			}
			верните это;
		}
		if ( селектор === false || селектор типа === "функция" ) {

			// (типы [, fn])
			фн = селектор;
			селектор = не определено;
		}
		если ( fn === ложь ) {
			фн = возвратложь;
		}
		верните this.each( function() {
			jQuery.event.remove(this, типы, fn, селектор);
		});
	}
});


вар

	// Поддержка: IE <= 10–11, только Edge 12–13
	// В IE/Edge использование групп регулярных выражений приводит к серьезному замедлению работы.
	// См. https://connect.microsoft.com/IE/feedback/details/1736512/.
	rnoInnerhtml = /<script|<style|<link/i,

	// проверено="проверено" или проверено
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Предпочитаем tbody родительской таблице для содержания новых строк
функция манипулированияTarget(элемент, содержимое) {
	if (nodeName(elem, "table") &&
		nodeName(content.nodeType!== 11? content: content.firstChild, "tr" )) {

		return jQuery(elem).children("tbody")[0] || элем;
	}

	вернуть элемент;
}

// Заменяем/восстанавливаем атрибут type элементов скрипта для безопасного манипулирования DOM
функция DisableScript(элемент) {
	elem.type = ( elem.getAttribute("type") !== null ) + "/" + elem.type;
	вернуть элемент;
}
функция restorScript(элемент) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice(5);
	} еще {
		elem.removeAttribute("тип");
	}

	вернуть элемент;
}

функция cloneCopyEvent(src, dest) {
	вар я, л, тип, pdataOld, udataOld, udataCur, события;

	если ( dest.nodeType !== 1 ) {
		возвращаться;
	}

	// 1. Копируем приватные данные: события, обработчики и т.д.
	если ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get(источник);
		события = pdataOld.events;

		если (события) {
			dataPriv.remove(dest, "обработка событий");

			for (введите события) {
				for (i = 0, l = события[тип].length; i < l; i++) {
					jQuery.event.add(dest, type,events[type][i]);
				}
			}
		}
	}

	// 2. Копируем данные пользователя
	если ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access(src);
		udataCur = jQuery.extend( {}, udataOld);

		dataUser.set(dest, udataCur);
	}
}

// Исправляем ошибки IE, см. тесты поддержки
функция fixInput( источник, место назначения ) {
	вар имя_узла = dest.nodeName.toLowerCase();

	// Не удается сохранить проверенное состояние клонированного флажка или переключателя.
	if (nodeName === "input" && rcheckableType.test(src.type) ) {
		dest.checked = источник.checked;

	// Не удается вернуть выбранную опцию в выбранное по умолчанию состояние при клонировании опций
	} else if (nodeName === "input" || nodeName === "textarea") {
		dest.defaultValue = src.defaultValue;
	}
}

функция domManip(коллекция, аргументы, обратный вызов, игнорируется) {

	// Сглаживание любых вложенных массивов
	args = квартира (args);

	фрагмент var, первый, скрипты, hasScripts, узел, документ,
		я = 0,
		l = коллекция.длина,
		iNoClone = l - 1,
		значение = аргументы[0],
		значениеIsFunction = isFunction (значение);

	// Мы не можем клонировать фрагменты Node, содержащие отмеченный флажок, в WebKit
	если (значениеIsFunction ||
			( l > 1 && значение типа === "строка" &&
				!support.checkClone && rchecked.test(значение) ) ) {
		вернуть коллекцию.each(функция(индекс) {
			вар self = Collection.eq(индекс);
			если (valueIsFunction) {
				args[0] = value.call(this, index, self.html());
			}
			domManip(self, args, обратный вызов, игнорируется);
		});
	}

	если ( л ) {
		фрагмент = buildFragment(args, коллекция[0].ownerDocument, false, коллекция, игнорируется);
		первый = фрагмент.FirstChild;

		если ( фрагмент.childNodes.length === 1 ) {
			фрагмент = первый;
		}

		// Требуется либо новый контент, либо интерес к игнорируемым элементам для вызова обратного вызова
		if (сначала || игнорируется) {
			scripts = jQuery.map(getAll(фрагмент, "скрипт"),disableScript);
			hasScripts = scripts.length;

			// Используем исходный фрагмент для последнего элемента
			// вместо первого, потому что это может закончиться
			// в определенных ситуациях опорожняется неправильно (trac-8070).
			для ( ; я < l; я++ ) {
				узел = фрагмент;

				если ( я !== iNoClone ) {
					узел = jQuery.clone(узел, правда, правда);

					// Сохраняем ссылки на клонированные скрипты для последующего восстановления
					если (hasScripts) {

						// Поддержка: только Android <= 4.0, только PhantomJS 1
						// push.apply(_, arraylike) вызывает древний WebKit
						jQuery.merge(скрипты, getAll(узел, "скрипт"));
					}
				}

				callback.call(коллекция[i], node, i);
			}

			если (hasScripts) {
				doc = скрипты[scripts.length - 1].ownerDocument;

				// Повторно включаем скрипты
				jQuery.map(скрипты,restoreScript);

				// Оценка исполняемых сценариев при первой вставке документа
				for (я = 0; я <hasScripts; я++) {
					узел = сценарии [я];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access(узел, "globalEval") &&
						jQuery.contains(документ, узел) ) {

						if ( node.src && ( node.type || "" ).toLowerCase() !== "модуль") {

							// Необязательная зависимость AJAX, но скрипты не будут запускаться, если они отсутствуют
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									одноразовый номер: node.nonce || node.getAttribute("нонсе")
								}, док);
							}
						} еще {

							// Разворачиваем раздел CDATA, содержащий содержимое скрипта. Это не должно быть
							// необходимы, поскольку в XML-документах они уже не видны, когда
							// проверка содержимого элементов, а в HTML-документах их нет
							// имеет значение, но мы сохраняем эту логику для обратной совместимости.
							// Это будет полностью удалено в версии 4.0. См. gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	возврат сбора;
}

функция удаления (элемент, селектор, KeepData) {
	вар узел,
		узлы = селектор? jQuery.filter(селектор, элем): элем,
		я = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData(getAll(узел));
		}

		если (узел.parentNode) {
			если (keepData && isAttached(узел)) {
				setGlobalEval(getAll(узел, "скрипт"));
			}
			node.parentNode.removeChild(узел);
		}
	}

	вернуть элемент;
}

jQuery.extend( {
	htmlPrefilter: функция (html) {
		вернуть HTML;
	},

	клон: функция (elem, dataAndEvents, deepDataAndEvents) {
		вар я, л, srcElements, destElements,
			клон = elem.cloneNode(истина),
			inPage = isAttached(элемент);

		// Исправление проблем с клонированием IE
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc(элемент) ) {

			// Здесь мы избегаем jQuery#find из соображений производительности:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll(клон);
			srcElements = getAll(элемент);

			for (i = 0, l = srcElements.length; i < l; i++) {
				fixInput(srcElements[i], destElements[i]);
			}
		}

		// Копируем события из оригинала в клон
		если ( dataAndEvents ) {
			если ( deepDataAndEvents ) {
				srcElements = srcElements || ПолучитьВсе(Элемент);
				destElements = destElements || получить все (клон);

				for (i = 0, l = srcElements.length; i < l; i++) {
					cloneCopyEvent(srcElements[i], destElements[i]);
				}
			} еще {
				cloneCopyEvent(элемент, клон);
			}
		}

		// Сохраняем историю оценки скрипта
		destElements = getAll(клон, «скрипт»);
		если ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll(elem, "script" ) );
		}

		// Возвращаем клонированный набор
		вернуть клон;
	},

	CleanData: функция (элементы) {
		данные var, элемент, тип,
			специальный = jQuery.event.special,
			я = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			если (принятые данные (элем) ) {
				если ( ( данные = элемент [ dataPriv.expando ] ) ) {
					если (данные.события) {
						for (введите data.events) {
							если (специальный[тип]) {
								jQuery.event.remove(элемент, тип);

							// Это ярлык, позволяющий избежать накладных расходов jQuery.event.remove
							} еще {
								jQuery.removeEvent(элемент, тип, data.handle);
							}
						}
					}

					// Поддержка: Chrome <=35 – 45+
					// Назначаем неопределенное значение вместо использования удаления, см. Data#remove
					элемент [dataPriv.expando] = не определено;
				}
				если ( элем [ dataUser.expando ] ) {

					// Поддержка: Chrome <=35 – 45+
					// Назначаем неопределенное значение вместо использования удаления, см. Data#remove
					элемент [dataUser.expando] = не определено;
				}
			}
		}
	}
});

jQuery.fn.extend( {
	отсоединить: функция (селектор) {
		вернуть удаление (это, селектор, правда);
	},

	удалить: функция (селектор) {
		return удалить(это, селектор);
	},

	текст: функция(значение) {
		возврат доступа (это, функция (значение) {
			возвращаемое значение === неопределенное?
				jQuery.text(это):
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = значение;
					}
				});
		}, ноль, значение, аргументы.длина);
	},

	добавить: функция() {
		return domManip( this, аргументы, функция (elem) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				вар цель = манипулированиеTarget (это, элемент);
				target.appendChild(элемент);
			}
		});
	},

	добавить: function() {
		return domManip( this, аргументы, функция (elem) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				вар цель = манипулированиеTarget (это, элемент);
				target.insertBefore(elem, target.firstChild);
			}
		});
	},

	до: функция() {
		return domManip( this, аргументы, функция (elem) {
			если ( this.parentNode ) {
				this.parentNode.insertBefore(элемент, это);
			}
		});
	},

	после: функция() {
		return domManip( this, аргументы, функция (elem) {
			если ( this.parentNode ) {
				this.parentNode.insertBefore(elem, this.nextSibling);
			}
		});
	},

	пусто: функция() {
		вар элем,
			я = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			если ( elem.nodeType === 1 ) {

				// Предотвращаем утечки памяти
				jQuery.cleanData(getAll(elem, false));

				// Удаляем все оставшиеся узлы
				elem.textContent = "";
			}
		}

		верните это;
	},

	клон: функция (dataAndEvents, deepDataAndEvents) {
		dataAndEvents = dataAndEvents == null? ложь: данныеAndEvents;
		deepDataAndEvents = deepDataAndEvents == null? данныеAndEvents: deepDataAndEvents;

		верните this.map( function() {
			вернуть jQuery.clone(this, dataAndEvents, deepDataAndEvents);
		});
	},

	HTML: функция (значение) {
		возврат доступа (это, функция (значение) {
			вар элем = это[ 0 ] || {},
				я = 0,
				l = эта.длина;

			if (значение === неопределенное && elem.nodeType === 1) {
				вернуть элемент.innerHTML;
			}

			// Посмотрим, сможем ли мы воспользоваться ярлыком и просто использовать InternalHTML
			if ( typeof value === "string" && !rnoInnerhtml.test(value) &&
				!wrapMap[ (rtagName.exec(value) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				значение = jQuery.htmlPrefilter(значение);

				пытаться {
					для ( ; я < l; я++ ) {
						элем = это [ я ] || {};

						// Удаляем узлы элементов и предотвращаем утечки памяти
						если ( elem.nodeType === 1 ) {
							jQuery.cleanData(getAll(elem, false));
							элемент.innerHTML = значение;
						}
					}

					элемент = 0;

				// Если использование InnerHTML вызывает исключение, используйте резервный метод
				} поймать ( е ) {}
			}

			если ( элем ) {
				this.empty().append(значение);
			}
		}, ноль, значение, аргументы.длина);
	},

	replaceWith: функция() {
		вар игнорируется = [];

		// Вносим изменения, заменяя каждый неигнорируемый элемент контекста новым содержимым
		return domManip( this, аргументы, функция (elem) {
			вар родительский = this.parentNode;

			if ( jQuery.inArray( это, игнорируется ) < 0 ) {
				jQuery.cleanData(getAll(this));
				если (родитель) {
					родитель.replaceChild(элемент, это);
				}
			}

		// Принудительный вызов обратного вызова
		}, игнорируется);
	}
});

jQuery.each( {
	AppendTo: "добавить",
	prependTo: "в начале",
	InsertBefore: "перед",
	InsertAfter: "после",
	replaceAll: "replaceWith"
}, функция(имя, оригинал) {
	jQuery.fn[имя] = функция(селектор) {
		вар элементы,
			врет = [],
			вставить = jQuery(селектор),
			последний = вставка.длина - 1,
			я = 0;

		для ( ; я <= последний; я++ ) {
			элементы = я === последний? это: this.clone(истина);
			jQuery(insert[i])[оригинал](elems);

			// Поддержка: только Android <= 4.0, только PhantomJS 1
			// .get(), потому что push.apply(_, arraylike) выдает ошибку в древнем WebKit
			push.apply(рет, elems.get());
		}

		вернуть this.pushStack(рет);
	};
});
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[az%]+$", "i" );

вар rcustomProp = /^--/;


вар getStyles = функция (элемент) {

		// Поддержка: только IE <= 11, Firefox <= 30 (trac-15098, trac-14150)
		// IE выдает элементы, созданные во всплывающих окнах
		// Тем временем FF выбрасывает элементы кадра через "defaultView.getComputedStyle"
		вар вид = elem.ownerDocument.defaultView;

		если ( !view || !view.opener ) {
			вид = окно;
		}

		вернуть view.getComputedStyle(элемент);
	};

var swap = функция (elem, options, обратный вызов) {
	вар рет, имя,
		старый = {};

	// Запомним старые значения и вставим новые
	for (имя в настройках) {
		old[имя] = elem.style[имя];
		elem.style[имя] = параметры[имя];
	}

	ret = callback.call(элемент);

	// Возвращаем старые значения
	for (имя в настройках) {
		elem.style[имя] = старое[имя];
	}

	вернуть возврат;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



(функция() {

	// Для выполнения тестов PixelPosition и BoxSizingReliable требуется только один макет
	// поэтому они выполняются одновременно, чтобы сохранить второе вычисление.
	функция ComputeStyleTests() {

		// Это синглтон, нам нужно выполнить его только один раз
		если ( !див ) {
			возвращаться;
		}

		Container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"позиция: относительная; отображение: блок; размер коробки: граница; переполнение: прокрутка;" +
			"маржа: авто; граница: 1 пиксель; отступ: 1 пиксель;" +
			"ширина: 60%; верх: 1%";
		documentElement.appendChild(контейнер).appendChild(div);

		вар divStyle = window.getComputedStyle(div);
		PixelPositionVal = divStyle.top !== "1%";

		// Поддержка: только Android 4.0–4.3, Firefox <=3–44
		надежныйMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

		// Поддержка: только Android 4.0–4.3, Safari <=9.1–10.1, iOS <=7.0–9.3
		// Некоторые стили возвращаются с процентными значениями, хотя они не должны
		div.style.right = "60%";
		PixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

		// Поддержка: только IE 9–11
		// Обнаружение неправильного определения размеров содержимого для элементов box-sizing:border-box
		boxSizingReliableVal = roundPixelMeasures (divStyle.width) === 36;

		// Поддержка: только IE 9
		// Обнаружение переполнения: прокрутка (gh-3699)
		// Поддержка: Chrome <=64
		// Не дайте себя обмануть, если масштаб влияет на offsetWidth (gh-4029)
		div.style.position = "абсолютный";
		ScrollboxSizeVal = roundPixelMeasures (div.offsetWidth / 3) === 12;

		documentElement.removeChild(контейнер);

		// Обнуляем элемент div, чтобы он не сохранялся в памяти и
		// это также будет признаком того, что проверки уже выполнены
		делитель = ноль;
	}

	функция roundPixelMeasures(мера) {
		return Math.round(parseFloat(мера));
	}

	вар PixelPositionVal, boxSizingReliableVal, ScrollboxSizeVal, PixelBoxStylesVal,
		надежныйTrDimensionsVal, надежныйMarginLeftVal,
		контейнер = document.createElement("div"),
		div = document.createElement("div");

	// Заканчиваем раньше в ограниченных (не браузерных) средах
	если (!div.style) {
		возвращаться;
	}

	// Поддержка: только IE <=9–11
	// Стиль клонированного элемента влияет на клонированный исходный элемент (trac-8908)
	div.style.backgroundClip = "окно содержимого";
	div.cloneNode(true).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "окно содержимого";

	jQuery.extend(поддержка, {
		boxSizingReliable: function() {
			ВычислитьСтильТесты();
			вернуть boxSizingReliableVal;
		},
		пиксельные стили: функция() {
			ВычислитьСтильТесты();
			вернуть PixelBoxStylesVal;
		},
		пиксельное положение: функция() {
			ВычислитьСтильТесты();
			вернуть значение пикселяPositionVal;
		},
		надежныйМаргинЛефт: функция() {
			ВычислитьСтильТесты();
			вернуть надежныйMarginLeftVal;
		},
		ScrollboxSize: функция() {
			ВычислитьСтильТесты();
			вернуть прокруткуSizeVal;
		},

		// Поддержка: IE 9–11+, Edge 15–18+
		// IE/Edge неправильно сообщает `getComputedStyle` строк таблицы с шириной/высотой
		// устанавливается в CSS, а свойства `offset*` сообщают правильные значения.
		// Поведение в IE 9 более тонкое, чем в более новых версиях, и оно проходит
		// некоторые версии этого теста; постарайтесь не пройти туда!
		//
		// Поддержка: Firefox 70+
		// Только Firefox включает ширину границ
		// в вычисленных размерах. (gh-4529)
		надежныйTrDimensions: function() {
			таблица var, tr, trChild, trStyle;
			если (надёжныйTrDimensionsVal == null) {
				таблица = document.createElement("таблица");
				tr = document.createElement("tr");
				trChild = document.createElement("div");

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px Solid";

				// Поддержка: Chrome 86+
				// Высота, установленная через cssText, не применяется.
				// Затем вычисленная высота возвращается к 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Поддержка: Android 8 Chrome 86+
				// В нашем iframe bodyBackground.html
				// отображение для всех элементов div установлено на «встроенное»,
				// что вызывает проблему только в Android 8 Chrome 86.
				// Обеспечение того, чтобы div был `display:block`
				// обходит эту проблему.
				trChild.style.display = "блокировать";

				ДокументЭлемент
					.appendChild(таблица)
					.appendChild( тр )
					.appendChild(trChild);

				trStyle = window.getComputedStyle(tr);
				надежныйTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild(таблица);
			}
			вернуть надежныйTrDimensionsVal;
		}
	});
} )();


функция curCSS(элемент, имя, вычислено) {
	ширина вар, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test(имя),

		// Поддержка: Firefox 51+
		// Получение стиля перед каким-либо вычислением
		// исправляет проблему с получением неправильных значений
		// на отдельных элементах
		стиль = элемент.стиль;

	вычислено = вычислено || getStyles(элемент);

	// getPropertyValue необходим для:
	// .css('filter') (только IE 9, trac-12537)
	// .css('--customProperty) (gh-3144)
	если (вычислено) {

		// Поддержка: IE <=9 - 11+
		// IE поддерживает только `"float"` в `getPropertyValue`; в вычисляемых стилях
		// он доступен только как `"cssFloat"`. Мы больше не изменяем свойства
		// отправляется в `.css()` отдельно от CamelCasing, поэтому нам нужно проверить оба.
		// Обычно это создает разницу в поведении: если
		// `getPropertyValue` возвращает пустую строку, возвращаемое значение
		// с помощью `.css()` будет `unопределён`. Обычно это касается
		// отключенные элементы. Однако в IE даже отключенные элементы
		// без стилей возвращаем `"none"` для `getPropertyValue( "float")`
		ret = вычисляемый.getPropertyValue(имя) || вычислено [имя];

		если ( isCustomProp && ret ) {

			// Поддержка: Firefox 105+, Chrome <=105+
			// Спецификация требует удаления пробелов для пользовательских свойств (gh-4926).
			// Firefox обрезает только начальные пробелы. Хром просто разваливается
			// как начальные, так и конечные пробелы равны одному пробелу.
			//
			// Возвращаемся к `undefed`, если возвращается пустая строка.
			// Это сворачивает отсутствующее определение с определенным свойством
			// и устанавливаем пустую строку, но стандартного API нет
			// что позволяет нам различать их без потери производительности
			// и возврат `unопределённого` соответствует более старой версии jQuery.
			//
			// rtrimCSS обрабатывает U+000D CARRIAGE RETURN и U+000C FORM FEED
			// как пробелы, а в CSS нет, но это не проблема
			// потому что предварительная обработка CSS заменяет их на U+000A LINE FEED
			// (который *является* пробелом CSS)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace(rtrimCSS, "$1") || неопределенный;
		}

		if ( ret === "" && !isAttached(elem) ) {
			ret = jQuery.style(элемент, имя);
		}

		// Дань уважения «потрясающему хаку Дина Эдвардса»
		// Браузер Android возвращает процент для некоторых значений,
		// но ширина, похоже, надежно равна пикселям.
		// Это противоречит черновой спецификации CSSOM:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Запоминаем исходные значения
			ширина = стиль.ширина;
			минШирина = стиль.минШирина;
			maxWidth = style.maxWidth;

			// Вводим новые значения, чтобы получить вычисленное значение
			style.minWidth = style.maxWidth = style.width = ret;
			ret = вычисленная ширина;

			// Возвращаем измененные значения
			стиль.ширина = ширина;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	вернуть возврат !== не определено?

		// Поддержка: только IE <=9–11
		// IE возвращает значение zIndex как целое число.
		Рет + "" :
		в отставку;
}


функция addGetHookIf(conditionFn,ookFn) {

	// Определим хук, при первом запуске проверим, действительно ли он нужен.
	возвращаться {
		получить: функция() {
			если ( условиеFn() ) {

				// Хук не нужен (или его невозможно использовать из-за
				// отсутствующей зависимости), удалите ее.
				удалить этот.get;
				возвращаться;
			}

			// Нужен хук; переопределите его, чтобы тест поддержки не выполнялся снова.
			return (this.get =ookFn).apply(this, аргументы);
		}
	};
}


var cssPrefixes = ["Webkit", "Moz", "ms"]
	пустойStyle = document.createElement("div").style,
	вендорПропс = {};

// Возвращаем свойство с префиксом поставщика или неопределенное
функцияvendorPropName(имя) {

	// Проверяем имена с префиксом поставщиков
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		я = cssPrefixes.length;

	в то время как я-- ) {
		имя = cssPrefixes[i] + capName;
		if (имя в пустом стиле) {
			вернуть имя;
		}
	}
}

// Возвращаем потенциально сопоставленное свойство jQuery.cssProps или свойство с префиксом поставщика
функция FinalPropName(имя) {
	var Final = jQuery.cssProps[имя] || вендорПропс[имя];

	если ( окончательный ) {
		возврат окончательный;
	}
	if (имя в пустом стиле) {
		вернуть имя;
	}
	returnvendorProps[имя] =vendorPropName(имя) || имя;
}


вар

	// Можно поменять местами, если отображение отсутствует или начинается с таблицы
	// кроме "таблицы", "таблицы-ячейки" или "таблицы-заголовка"
	// Отображаемые значения см. здесь: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { позиция: «абсолютная», видимость: «скрытый», дисплей: «блокировать» },
	cssNormalTransform = {
		интервал между буквами: «0»,
		ШрифтВес: "400"
	};

функция setPositiveNumber(_elem, значение, вычитание) {

	// Любые относительные (+/-) значения уже были
	// нормализовано на этом этапе
	var match = rcssNum.exec(значение);
	ответные матчи?

		// Защита от неопределенного «вычитания», например, при использовании, как в cssHooks
		Math.max( 0, match[ 2 ] - ( вычесть || 0 )) + ( match[ 3 ] || "px" ):
		ценить;
}

function boxModelAdjustment(elem, Dimension, Box, isBorderBox, Styles, ComputedVal) {
	вар я = размер === "ширина"? 1 : 0,
		дополнительно = 0,
		дельта = 0,
		маржаДельта = 0;

	// Настройка может не потребоваться
	if (box === (isBorderBox? «граница»: «содержимое»)) {
		вернуть 0;
	}

	для ( ; я < 4; я += 2 ) {

		// Обе блочные модели исключают маржу
		// Подсчитываем дельту поля отдельно, чтобы добавить ее только после регулировки поля прокрутки.
		// Это необходимо, чтобы отрицательные поля работали с `outerHeight( true )` (gh-3982).
		if (box === "маржа") {
			MarginDelta += jQuery.css(elem, box + cssExpand[i], true,styles);
		}

		// Если мы приходим сюда с полем содержимого, мы ищем «отступы», «границы» или «поля»
		если (!isBorderBox) {

			// Добавляем отступы
			delta += jQuery.css(elem, "padding" + cssExpand[i], true,styles);

			// Для «границы» или «поля» добавьте границу
			if (box !== "padding") {
				delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true,styles );

			// Но в противном случае все равно отслеживайте это
			} еще {
				extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true,styles );
			}

		// Если мы попадаем сюда с рамкой (контент + отступ + граница), мы ищем «контент» или
		// «отступ» или «поля»
		} еще {

			// Для «контента» вычитаем отступы
			if (box === "содержание") {
				delta -= jQuery.css(elem, "padding" + cssExpand[i], true,styles);
			}

			// Для «контента» или «отступа» вычитаем границу
			if (коробка !== "маржа") {
				delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true,styles );
			}
		}
	}

	// Учет положительного поля прокрутки поля содержимого по запросу путем предоставления вычисляемого значения
	if ( !isBorderBox && вычисленное значение >= 0 ) {

		// offsetWidth/offsetHeight — это округленная сумма содержимого, отступов, поля прокрутки и границы
		// Предполагая, что полоса прокрутки целочисленная, вычитаем остальное и округляем вниз
		дельта += Math.max( 0, Math.ceil(
			elem[ "смещение" + измерение[0].toUpperCase() + измерение.slice(1)] -
			вычисленное значение -
			дельта -
			дополнительный -
			0,5

		// Если offsetWidth/offsetHeight неизвестен, мы не можем определить полосу прокрутки поля содержимого
		// Используйте явный ноль, чтобы избежать NaN (gh-3964)
		) ) || 0;
	}

	вернуть дельту + маржуДельта;
}

function getWidthOrHeight(elem, Dimension, Extra) {

	// Начинаем с вычисленного стиля
	вар стили = getStyles(elem),

		// Чтобы избежать принудительной перекомпоновки, извлекайте boxSizing только в том случае, если он нам нужен (gh-4322).
		// Поддельное поле содержимого, пока мы не узнаем, что необходимо знать истинное значение.
		boxSizingNeeded = !support.boxSizingReliable() || дополнительный,
		isBorderBox = boxSizingNeeded &&
			jQuery.css(elem, "boxSizing", false,styles) === "border-box",
		значениеIsBorderBox = isBorderBox,

		val = curCSS(элемент, размер, стили),
		offsetProp = "смещение" + измерение [0].toUpperCase() + измерение.slice(1);

	// Поддержка: Firefox <=54
	// Возвращаем сбивающее с толку значение, не являющееся пикселем, или симулируем незнание, в зависимости от ситуации.
	если ( rnumnonpx.test( val ) ) {
		если ( !extra ) {
			вернуть значение;
		}
		вал = «авто»;
	}


	// Поддержка: только IE 9–11
	// Используйте offsetWidth/offsetHeight, если размер поля ненадежен.
	// В этих случаях вычисленное значение может считаться рамкой.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Поддержка: IE 10–11+, Edge 15–18+
		// IE/Edge неправильно сообщает `getComputedStyle` строк таблицы с шириной/высотой
		// устанавливается в CSS, а свойства `offset*` сообщают правильные значения.
		// Интересно, что в некоторых случаях IE 9 не страдает от этой проблемы.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Возвращаемся к offsetWidth/offsetHeight, когда значение «auto»
		// Это происходит для встроенных элементов без явных настроек (gh-3571)
		вал === "авто" ||

		// Поддержка: только Android <= 4.1–4.3
		// Также используйте offsetWidth/offsetHeight для неверно указанных линейных размеров (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false,styles ) === "inline" ) &&

		// Убедитесь, что элемент виден и подключен
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css(elem, "boxSizing", false,styles) === "border-box";

		// Если доступно, offsetWidth/offsetHeight приблизительные размеры рамки.
		// Там, где это невозможно (например, SVG), предположим ненадежный размер блока и интерпретируем
		// полученное значение как размер поля содержимого.
		valueIsBorderBox = offsetProp в элементе;
		если (valueIsBorderBox) {
			val = элемент [offsetProp];
		}
	}

	// Нормализовать "" и авто
	значение = parseFloat(знач) || 0;

	// Корректируем блочную модель элемента
	возврат (значение +
		boxModelAdjustment(
			элемент,
			измерение,
			дополнительный || ( isBorderBox ? «граница»: «содержимое»),
			значениеIsBorderBox,
			стили,

			// Укажите текущий вычисленный размер для запроса расчета прокрутки (gh-3589)
			вал
		)
	) + «пкс»;
}

jQuery.extend( {

	// Добавляем хуки свойств стиля для переопределения значения по умолчанию
	// поведение при получении и установке свойства стиля
	cssHooks: {
		непрозрачность: {
			получить: функция (элем, вычислено) {
				если (вычислено) {

					// Мы всегда должны получать число из непрозрачности
					var ret = curCSS(elem, «непрозрачность»);
					return ret === "" ? «1»: в отставку;
				}
			}
		}
	},

	// Не добавлять автоматически "px" к этим, возможно, безразмерным свойствам
	cssNumber: {
		анимацияИтерацияКаунт: правда,
		аспектСоотношение: правда,
		границаImageSlice: правда,
		КолонкаКолонка: правда,
		flexGrow: правда,
		flexShrink: правда,
		шрифтВес: правда,
		GridArea: правда,
		сеткаКолонка: правда,
		GridColumnEnd: правда,
		сеткаКолумнСтарт: правда,
		сеткаРов: правда,
		GridRowEnd: правда,
		сеткаРовСтарт: правда,
		линияВысота: правда,
		непрозрачность: правда,
		порядок: правда,
		сироты: правда,
		масштаб: правда,
		вдовы: правда,
		zИндекс: правда,
		масштабирование: правда,

		// Связанный с SVG
		fillOpacity: правда,
		FloodOpacity: правда,
		стопOpacity: правда,
		инсультМитерлимит: правда,
		ходНепрозрачность: правда
	},

	// Добавьте свойства, имена которых вы хотите исправить раньше
	// установка или получение значения
	cssProps: {},

	// Получаем и устанавливаем свойство стиля на узле DOM
	стиль: функция (элемент, имя, значение, дополнительно) {

		// Не устанавливайте стили для узлов текста и комментариев
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			возвращаться;
		}

		// Убедитесь, что мы работаем с правильным именем
		var ret, тип, крючки,
			origName = CamelCase(имя),
			isCustomProp = rcustomProp.test(имя),
			стиль = элемент.стиль;

		// Убедитесь, что мы работаем с правильным именем. Мы не
		// хотим запросить значение, если оно является пользовательским свойством CSS
		// поскольку они определяются пользователем.
		если (!isCustomProp) {
			имя = FinalPropName (оригинальное имя);
		}

		// Получает перехват для версии с префиксом, а затем для версии без префикса
		хуки = jQuery.cssHooks[имя] || jQuery.cssHooks[имя_оригинала];

		// Проверяем, устанавливаем ли мы значение
		если (значение!== неопределенное) {
			тип = значение типа;

			// Преобразование "+=" или "-=" в относительные числа (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				значение = корректировкаCSS(элемент, имя, ret);

				// Исправляет ошибку trac-9237
				тип = «число»;
			}

			// Убедитесь, что значения NULL и NaN не установлены (trac-7116)
			if (значение == ноль || значение!== значение) {
				возвращаться;
			}

			// Если было передано число, добавьте единицу измерения (за исключением некоторых свойств CSS)
			// Проверку isCustomProp можно удалить в jQuery 4.0, когда мы добавляем только автоматически
			// "px" к нескольким жестко запрограммированным значениям.
			if ( type === "number" && !isCustomProp) {
				значение += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// реквизит background-* влияет на значения исходного клона
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				стиль [имя] = «наследовать»;
			}

			// Если был предоставлен хук, используйте это значение, в противном случае просто установите указанное значение
			if ( !hooks || !( "установить" в хуки) ||
				(value =ooks.set(elem, value, extra)) !== undefined ) {

				если ( isCustomProp ) {
					style.setProperty(имя, значение);
				} еще {
					стиль [имя] = значение;
				}
			}

		} еще {

			// Если был предоставлен хук, получим оттуда невычисленное значение
			if ( хуки && "получить" в хуки &&
				( ret =ooks.get(elem, false, extra) ) !== не определено ) {

				вернуть возврат;
			}

			// В противном случае просто получаем значение из объекта стиля
			вернуть стиль [имя];
		}
	},

	css: функция (элемент, имя, дополнительно, стили) {
		вар вал, число, крючки,
			origName = CamelCase(имя),
			isCustomProp = rcustomProp.test(имя);

		// Убедитесь, что мы работаем с правильным именем. Мы не
		// хотим изменить значение, если это пользовательское свойство CSS
		// поскольку они определяются пользователем.
		если (!isCustomProp) {
			имя = FinalPropName (оригинальное имя);
		}

		// Попробуйте имя с префиксом, за которым следует имя без префикса
		хуки = jQuery.cssHooks[имя] || jQuery.cssHooks[имя_оригинала];

		// Если был предоставлен хук, получим вычисленное значение оттуда
		if (хуки && "получить" в хуках) {
			val =ooks.get(elem, true, extra);
		}

		// В противном случае, если существует способ получить вычисленное значение, используйте его
		если (значение === неопределенное) {
			val = curCSS(элемент, имя, стили);
		}

		// Преобразуем «нормальное» в вычисленное значение
		if ( val === "normal" && имя в cssNormalTransform ) {
			val = cssNormalTransform [имя];
		}

		// Сделать числовым, если принудительно или был указан квалификатор, и значение val выглядит числовым
		если (экстра === "" || экстра ) {
			число = parseFloat(значение);
			вернуть дополнительно === true || isFinite (число)? число || 0: значение;
		}

		вернуть значение;
	}
});

jQuery.each([ "высота", "ширина"], function( _i, измерение) {
	jQuery.cssHooks[размерность] = {
		получить: функция (элем, вычислено, дополнительно) {
			если (вычислено) {

				// Определенные элементы могут иметь информацию о размерах, если мы их невидимо показываем
				// но он должен иметь текущий стиль отображения, который принесет пользу
				return rdisplayswap.test(jQuery.css(elem, "display")) &&

					// Поддержка: Safari 8+
					// Столбцы таблицы в Safari имеют ненулевое значение offsetWidth и ноль
					// getBoundingClientRect().width, если отображение не изменено.
					// Поддержка: только IE <= 11
					// Запуск getBoundingClientRect на отключенном узле
					// в IE выдает ошибку.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
					своп( элем, cssShow, функция() {
						вернуть getWidthOrHeight(элемент, размер, дополнительно);
					} ) :
					getWidthOrHeight(элемент, размер, дополнительно);
			}
		},

		set: function(elem, value, extra) {
			вар совпадений,
				стили = getStyles(элемент),

				// Читаем Styles.position только в том случае, если тест может завершиться неудачей
				// чтобы избежать принудительной перекомпоновки.
				ScrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "абсолютный",

				// Чтобы избежать принудительной перекомпоновки, извлекайте boxSizing только в том случае, если он нам нужен (gh-3991)
				boxSizingNeeded = прокруткаBoxSizeBuggy || дополнительный,
				isBorderBox = boxSizingNeeded &&
					jQuery.css(elem, "boxSizing", false,styles) === "border-box",
				вычесть = лишнее?
					boxModelAdjustment(
						элемент,
						измерение,
						дополнительный,
						isBorderBox,
						стили
					) :
					0;

			// Учет ненадежных размеров рамки путем сравнения смещения* с вычисленным и
			// подделываем поле содержимого, чтобы получить границу и отступы (gh-3699)
			if ( isBorderBox && ScrollboxSizeBuggy ) {
				вычесть -= Math.ceil(
					elem[ "смещение" + измерение[0].toUpperCase() + измерение.slice(1)] -
					parseFloat(стили[размерность]) -
					boxModelAdjustment(elem, измерение, «граница», false, стили) –
					0,5
				);
			}

			// Преобразование в пиксели, если требуется корректировка значения
			if (вычесть && (соответствует = rcssNum.exec(значение)) &&
				( match[ 3 ] || "px" ) !== "px" ) {

				elem.style[размер] = значение;
				значение = jQuery.css(элемент, измерение);
			}

			вернуть setPositiveNumber (элемент, значение, вычесть);
		}
	};
});

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	функция( элем, вычислено ) {
		если (вычислено) {
			return ( parseFloat(curCSS(elem, "marginLeft")) ||
				elem.getBoundingClientRect().left -
					своп( элем, {marginLeft: 0 }, функция() {
						return elem.getBoundingClientRect().left;
					} )
			) + «пкс»;
		}
	}
);

// Эти хуки используются в Animate для расширения свойств
jQuery.each( {
	допуск: "",
	дополнение: "",
	ширина рамки"
}, функция(префикс, суффикс) {
	jQuery.cssHooks[префикс + суффикс] = {
		развернуть: функция (значение) {
			вар я = 0,
				расширенный = {},

				// Предполагается одно число, если не строка
				части = значение типа === "строка" ? value.split(" "): [значение];

			для ( ; я < 4; я++ ) {
				расширенный[ префикс + cssExpand[ i ] + суффикс ] =
					части[ я ] || части[ я - 2 ] || части[ 0 ];
			}

			возврат расширен;
		}
	};

	if (префикс !== "маржа") {
		jQuery.cssHooks[префикс + суффикс].set = setPositiveNumber;
	}
});

jQuery.fn.extend( {
	css: функция(имя, значение) {
		возврат доступа (это, функция (элемент, имя, значение) {
			вар стили, Лен,
				карта = {},
				я = 0;

			если (Array.isArray(имя)) {
				стили = getStyles(элемент);
				лен = имя.длина;

				для ( ; я < len; я++ ) {
					карта[имя[i]] = jQuery.css(элемент, имя[i], false, стили);
				}

				карта возврата;
			}

			возвращаемое значение!== неопределенное?
				jQuery.style(элемент, имя, значение):
				jQuery.css(элемент, имя);
		}, имя, значение, аргументы.длина > 1);
	}
});


function Tween(elem, options, prop, end, easing) {
	вернуть новый Tween.prototype.init(elem, options, prop, end, easing);
}
jQuery.Tween = Твин;

Твин.прототип = {
	конструктор: Твин,
	init: function(elem, options, prop, end, easing, unit) {
		this.elem = элемент;
		this.prop = опора;
		this.easing = смягчение || jQuery.easing._default;
		this.options = параметры;
		this.start = this.now = this.cur();
		this.end = конец;
		this.unit = единица измерения || ( jQuery.cssNumber[prop] ? "" : "px" );
	},
	Cur: функция() {
		вар хуки = Tween.propHooks[this.prop];

		вернуть крючки &&ooks.get ?
			крючки.get(это):
			Tween.propHooks._default.get(это);
	},
	запустить: функция (проценты) {
		Вар облегчился,
			крючки = Tween.propHooks[this.prop];

		если ( this.options.duration ) {
			this.pos = облегченный = jQuery.easing[ this.easing ](
				процент, this.options.duration * процент, 0, 1, this.options.duration
			);
		} еще {
			this.pos = облегченный = процент;
		}
		this.now = ( this.end - this.start ) * облегченный + this.start;

		если ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( хуки && крючки.set ) {
			хуки.set(это);
		} еще {
			Tween.propHooks._default.set(это);
		}
		верните это;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_по умолчанию: {
		получить: функция (анимация) {
			вар результат;

			// Используйте свойство элемента напрямую, если он не является элементом DOM,
			// или когда не существует соответствующего свойства стиля.
			если ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[tween.prop];
			}

			// Передача пустой строки в качестве третьего параметра в .css автоматически
			// попытка parseFloat и возврат к строке, если синтаксический анализ не удался.
			// Простые значения, такие как «10px», преобразуются в Float;
			// сложные значения, такие как "rotate(1rad)", возвращаются как есть.
			result = jQuery.css(tween.elem, tween.prop, "");

			// Пустые строки, нулевые, неопределенные и «авто» преобразуются в 0.
			вернуть !результат || результат === "авто" ? 0: результат;
		},
		набор: функция (анимация) {

			// Используйте хук шага для обратной совместимости.
			// Используйте cssHook, если он есть.
			// Используйте .style, если он доступен, и используйте простые свойства, где это возможно.
			если ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[tween.prop](tween);
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[tween.prop] ||
					tween.elem.style[finalPropName(tween.prop)] != null ) ) {
				jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
			} еще {
				tween.elem[tween.prop] = tween.now;
			}
		}
	}
};

// Поддержка: только IE <=9
// Подход, основанный на панике, к настройке вещей на отключенных узлах
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	набор: функция (анимация) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[tween.prop] = tween.now;
		}
	}
};

jQuery.easing = {
	линейная: функция( р ) {
		вернуть р;
	},
	свинг: функция( р ) {
		вернуть 0,5 - Math.cos(p * Math.PI)/2;
	},
	_default: «качели»
};

jQuery.fx = Tween.prototype.init;

// Обратная совместимость <1,8 точки расширения
jQuery.fx.step = {};




вар
	fxNow, вПрогресс,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

расписание функции() {
	если (инПрогресс) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame(расписание);
		} еще {
			window.setTimeout(расписание, jQuery.fx.interval);
		}

		jQuery.fx.tick();
	}
}

// Анимации, созданные синхронно, будут выполняться синхронно
функция createFxNow() {
	window.setTimeout(функция() {
		fxNow = не определено;
	});
	return (fxNow = Date.now());
}

// Генерируем параметры для создания стандартной анимации
функция genFx(type, includeWidth) {
	вар который,
		я = 0,
		attrs = {высота: тип};

	// Если мы включим ширину, значение шага будет равно 1, чтобы выполнить все значения cssExpand,
	// в противном случае значение шага равно 2, чтобы пропустить левое и правое
	includeWidth = includeWidth? 1:0;
	для (; я <4; я += 2 - includeWidth) {
		который = cssExpand[я];
		attrs[ "маржа" +который ] = attrs[ "отступ" + который ] = тип;
	}

	если (includeWidth) {
		attrs.opacity = attrs.width = тип;
	}

	вернуть атрибуты;
}

функция createTween(значение, опора, анимация) {
	вар твин,
		коллекция = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ]),
		индекс = 0,
		длина = коллекция.длина;
	for ( ; индекс < длина; индекс++ ) {
		if ( ( tween = коллекция[индекс].call(анимация, опора, значение) ) ) {

			// Мы закончили с этим свойством
			вернуться в режим анимации;
		}
	}
}

function defaultPrefilter(elem, props, opts) {
	var prop, значение, переключение, крючки, oldfire, propTween, RestorationDisplay, дисплей,
		isBox = «ширина» в реквизите || «высота» в реквизите,
		аним = это,
		исходное значение = {},
		стиль = элемент.стиль,
		скрытый = elem.nodeType && isHiddenWithinTree(elem),
		dataShow = dataPriv.get(elem, "fxshow");

	// Анимация пропуска очереди перехватывает хуки fx
	если (!opts.queue) {
		хуки = jQuery._queueHooks(elem, "fx");
		если (хуки.unqueued == ноль) {
			крючки.unqueued = 0;
			oldfire =ooks.empty.fire;
			крючки.empty.fire = функция() {
				если (!hooks.unqueued) {
					старый огонь();
				}
			};
		}
		хуки.unqueued++;

		аним.всегда(функция() {

			// Убедитесь, что полный обработчик вызывается до завершения
			аним.всегда(функция() {
				хуки.unqueued--;
				if ( !jQuery.queue(elem, "fx" ).length ) {
					хуки.пустой.огонь();
				}
			});
		});
	}

	// Обнаружение показа/скрытия анимации
	for (реквизит в реквизите) {
		значение = реквизит [реквизит];
		если (rfxtypes.test(значение)) {
			удалить реквизит [prop];
			переключить = переключить || значение === "переключить";
			if (значение === (скрыто? «скрыть»: «показать»)) {

				// Притворяемся скрытыми, если это «шоу» и
				// еще есть данные от остановленного показа/скрытия
				if ( value === "show" && dataShow && dataShow[ prop ] !== не определено ) {
					скрытый = правда;

				// Игнорируем все остальные неактивные данные отображения/скрытия
				} еще {
					продолжать;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style(элемент, опора);
		}
	}

	// Выход из строя, если это неактивная операция, например .hide().hide()
	propTween = !jQuery.isEmptyObject(реквизит);
	if ( !propTween && jQuery.isEmptyObject(orig) ) {
		возвращаться;
	}

	// Ограничиваем стили «переполнение» и «отображение» во время анимации блока
	if ( isBox && elem.nodeType === 1 ) {

		// Поддержка: IE <= 9–11, Edge 12–15
		// Записываем все три атрибута переполнения, поскольку IE не выводит сокращение
		// из overflowX и overflowY с одинаковыми значениями и Edge просто зеркально отражаются
		// значение overflowX.
		opts.overflow = [style.overflow, style.overflowX, style.overflowY];

		// Определить тип отображения, предпочитая старые данные отображения/скрытия каскаду CSS
		restreDisplay = dataShow && dataShow.display;
		если (restoreDisplay == null) {
			restreDisplay = dataPriv.get(elem, "display");
		}
		display = jQuery.css(elem, "display");
		если (дисплей === "нет") {
			если (restoreDisplay) {
				дисплей = восстановитьДисплей;
			} еще {

				// Получаем непустые значения, временно устанавливая видимость
				showHide([элемент], правда);
				restreDisplay = elem.style.display || восстановитьДисплей;
				display = jQuery.css(elem, "display");
				showHide([элемент]);
			}
		}

		// Анимируем встроенные элементы как встроенный блок
		if ( display === "inline" || display === "inline-block" && restartDisplay != null ) {
			if ( jQuery.css(elem, "float") === "none" ) {

				// Восстанавливаем исходное отображаемое значение в конце чистой анимации показа/скрытия
				если ( !propTween ) {
					аним.done(функция() {
						стиль.дисплей = восстановлениеДисплей;
					});
					если (restoreDisplay == null) {
						дисплей = стиль.дисплей;
						restreDisplay = display === «нет»? "" : отображать;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	если (opts.overflow) {
		style.overflow = "скрытый";
		аним.всегда(функция() {
			style.overflow = opts.overflow[0];
			style.overflowX = opts.overflow[1];
			style.overflowY = opts.overflow[2];
		});
	}

	// Реализуем показ/скрытие анимации
	пропТвин = ложь;
	for (proper in orig) {

		// Общие настройки отображения/скрытия для анимации этого элемента
		если ( !propTween ) {
			если (dataShow) {
				if («скрыто» в dataShow) {
					скрытый = dataShow.hidden;
				}
			} еще {
				dataShow = dataPriv.access(elem, "fxshow", {display:restoreDisplay});
			}

			// Сохраняем скрытое/видимое для переключения, чтобы `.stop().toggle()` "переворачивал"
			если (переключить) {
				dataShow.hidden = !скрытый;
			}

			// Показываем элементы перед их анимацией
			если (скрыто) {
				showHide([элемент], правда);
			}

			/* eslint-disable функция без цикла */

			аним.done(функция() {

				/* функция eslint-enable без цикла */

				// Последний шаг анимации «скрытия» фактически скрывает элемент
				если ( !скрыто ) {
					showHide([элемент]);
				}
				dataPriv.remove(elem, "fxshow");
				for (proper in orig) {
					jQuery.style(elem, prop, orig[prop]);
				}
			});
		}

		// Настройка для каждого свойства
		propTween = createTween(скрытый? dataShow[prop]: 0, prop, anim);
		if ( !( опора в dataShow )) {
			dataShow[prop] = propTween.start;
			если (скрыто) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

функция propFilter(реквизит, SpecialEasing) {
	индекс var, имя, замедление, значение, хуки;

	// проход CamelCase, SpecialEasing и Expansion cssHook
	for (индекс в реквизите) {
		имя = CamelCase (индекс);
		easing = SpecialEasing[имя];
		значение = реквизит [индекс];
		если (Array.isArray(значение)) {
			смягчение = значение [1];
			значение = реквизит [индекс] = значение [0];
		}

		если (индекс!== имя) {
			реквизит [ имя] = значение;
			удалить реквизит [индекс];
		}

		хуки = jQuery.cssHooks[имя];
		if (хуки && «расширяются» в хуках) {
			значение = хуки.развернуть(значение);
			удалить реквизит [имя];

			// Не совсем $.extend, существующие ключи не будут перезаписаны.
			// Повторное использование «индекса», поскольку у нас есть правильное «имя»
			for (индекс в значении) {
				if ( !(индекс в реквизите)) {
					реквизит[индекс] = значение[индекс];
					SpecialEasing[индекс] = смягчение;
				}
			}
		} еще {
			SpecialEasing[имя] = смягчение;
		}
	}
}

функция Анимация (элемент, свойства, параметры) {
	вар результат,
		остановился,
		индекс = 0,
		длина = Animation.prefilters.length,
		отложенный = jQuery.Deferred().always( function() {

			// Не соответствовать элементу в селекторе :animated
			удалить тик.елем;
		} ),
		тик = функция() {
			если (остановлено) {
				вернуть ложь;
			}
			вар currentTime = fxNow || создатьFxNow(),
				остаток = Math.max( 0, анимация.startTime + анимация.длительность - текущеевремя),

				// Поддержка: только Android 2.3
				// Архаичная ошибка сбоя не позволяет нам использовать `1 - ( 0.5 || 0 )` (trac-12497)
				temp = оставшееся/animation.duration || 0,
				процент = 1 - температура,
				индекс = 0,
				длина = анимация.tweens.length;

			for ( ; индекс < длина; индекс++ ) {
				анимация.tweens[индекс].run(процент);
			}

			deferred.notifyWith(elem, [анимация, процент, остаток]);

			// Если есть что сделать, выдаем
			if (процент <1 && длина) {
				вернуть оставшееся;
			}

			// Если это была пустая анимация, синтезируем окончательное уведомление о ходе выполнения
			если ( !длина ) {
				deferred.notifyWith(elem, [animation, 1, 0]);
			}

			// Разрешаем анимацию и сообщаем о ее завершении
			deferred.resolveWith(elem, [анимация]);
			вернуть ложь;
		},
		анимация = deferred.promise( {
			элем: элем,
			реквизит: jQuery.extend( {}, свойства),
			выбор: jQuery.extend( true, {
				SpecialEasing: {},
				смягчение: jQuery.easing._default
			}, параметры ),
			originalProperties: свойства,
			оригинальныеОпции: параметры,
			время начала: fxNow || создатьFxNow(),
			продолжительность: options.duration,
			подростки: [],
			createTween: функция (prop, конец) {
				var tween = jQuery.Tween(elem,animation.opts,prop,end,
					анимация.opts.specialEasing[ опора ] || анимация.opts.easing );
				анимация.tweens.push(твин);
				вернуться в режим анимации;
			},
			стоп: функция (gotoEnd) {
				индекс вар = 0,

					// Если мы идем до конца, мы хотим запустить все твины
					// иначе мы пропускаем эту часть
					длина = перейти к концу? анимация.tweens.длина: 0;
				если (остановлено) {
					верните это;
				}
				остановлен = правда;
				for ( ; индекс < длина; индекс++ ) {
					анимация.tweens[индекс].run(1);
				}

				// Решить, когда мы воспроизвели последний кадр; в противном случае отклонить
				если (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} еще {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				верните это;
			}
		} ),
		реквизит = анимация.реквизит;

	propFilter(реквизит, анимация.opts.specialEasing);

	for ( ; индекс < длина; индекс++ ) {
		result = Animation.prefilters[index].call(animation, elem, props,animation.opts);
		если (результат) {
			если ( isFunction( result.stop ) ) {
				jQuery._queueHooks(animation.elem,animation.opts.queue).stop =
					result.stop.bind(результат);
			}
			вернуть результат;
		}
	}

	jQuery.map(реквизит, createTween, анимация);

	if ( isFunction(animation.opts.start) ) {
		анимация.opts.start.call(элемент, анимация);
	}

	// Прикрепляем обратные вызовы из опций
	анимация
		.progress(animation.opts.progress)
		.done( анимация.opts.done, анимация.opts.complete )
		.fail( анимация.opts.fail )
		.always(animation.opts.always);

	jQuery.fx.timer(
		jQuery.extend(тик, {
			элем: элем,
			анимация: анимация,
			очередь: анимация.opts.queue
		} )
	);

	возвратная анимация;
}

jQuery.Animation = jQuery.extend( Анимация, {

	твинеры: {
		"*": [функция(реквизит, значение) {
			var tween = this.createTween(prop, value);
			корректировкаCSS(tween.elem, prop, rcssNum.exec(значение), tween);
			вернуться в режим анимации;
		} ]
	},

	твинер: функция (реквизит, обратный вызов) {
		если ( isFunction ( реквизит ) ) {
			обратный вызов = реквизит;
			реквизит = [ "*" ];
		} еще {
			реквизит = props.match(rnothtmlwhite);
		}

		вар реквизит,
			индекс = 0,
			длина = реквизит.длина;

		for ( ; индекс < длина; индекс++ ) {
			опора = реквизит [индекс];
			Animation.tweeners[ опора ] = Animation.tweeners[ опора ] || [];
			Animation.tweeners[prop].unshift(обратный вызов);
		}
	},

	префильтры: [ defaultPrefilter ],

	префильтр: функция (обратный вызов, добавление) {
		если (вставить в начало) {
			Animation.prefilters.unshift(обратный вызов);
		} еще {
			Animation.prefilters.push(обратный вызов);
		}
	}
});

jQuery.speed = функция(скорость, замедление, fn) {
	var opt = скорость && тип скорости === "объект" ? jQuery.extend( {}, скорость): {
		завершено: фн || !fn && замедление ||
			isFunction( скорость ) && скорость,
		продолжительность: скорость,
		замедление: fn && замедление || ослабление && !isFunction(ослабление) && ослабление
	};

	// Переходим в конечное состояние, если эффекты отключены
	если ( jQuery.fx.off ) {
		опт.длительность = 0;

	} еще {
		if ( typeof opt.duration !== "number" ) {
			if (opt.duration в jQuery.fx.speeds) {
				opt.duration = jQuery.fx.speeds[opt.duration];

			} еще {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Нормализовать opt.queue - true/undefined/null -> "fx"
	if (opt.queue == null || opt.queue === true) {
		opt.queue = "FX";
	}

	// Очередь
	opt.old = opt.complete;

	opt.complete = функция() {
		если ( isFunction(opt.old) ) {
			opt.old.call(это);
		}

		если (opt.queue) {
			jQuery.dequeue(это, opt.queue);
		}
	};

	возврат опт;
};

jQuery.fn.extend( {
	FadeTo: функция (скорость, замедление, обратный вызов) {

		// Показать все скрытые элементы после установки непрозрачности на 0
		верните this.filter( isHiddenWithinTree ).css( "непрозрачность", 0).show()

			// Анимируем указанное значение
			.end().animate( { непрозрачность: до }, скорость, замедление, обратный вызов );
	},
	анимировать: функция (проп, скорость, замедление, обратный вызов) {
		вар пустой = jQuery.isEmptyObject(prop),
			optall = jQuery.speed(скорость, замедление, обратный вызов),
			doAnimation = функция() {

				// Работаем с копией свойства, чтобы не потерять плавность для каждого свойства
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Пустые анимации или немедленное завершение
				if (пусто || dataPriv.get(this, "finish")) {
					аним.стоп (истина);
				}
			};

		doAnimation.finish = doAnimation;

		вернуть пустой || optall.queue === ложь?
			this.each(doAnimation):
			this.queue(optall.queue, doAnimation);
	},
	стоп: функция (тип, ClearQueue, gotoEnd) {
		вар stopQueue = функция (перехватчики) {
			вар стоп =ooks.stop;
			удалить хуки.стоп;
			стоп (перейти к концу);
		};

		if ( typeof type !== "строка" ) {
			gotoEnd = очистить очередь;
			ClearQueue = тип;
			тип = неопределенный;
		}
		если (clearQueue) {
			this.queue( type || "fx", [] );
		}

		верните this.each( function() {
			вар dequeue = правда,
				индекс = тип!= ноль && тип + "queueHooks",
				таймеры = jQuery.timers,
				данные = dataPriv.get(это);

			если (индекс) {
				if (данные[индекс] && данные[индекс].stop ) {
					stopQueue(данные[индекс]);
				}
			} еще {
				for (индекс в данных) {
					if ( данные[индекс] && данные[индекс].stop && rrun.test(индекс) ) {
						stopQueue(данные[индекс]);
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					(тип == ноль || таймеры[индекс].очередь === тип)) {

					таймеры[индекс].anim.stop(gotoEnd);
					удалить из очереди = ложь;
					timers.splice(индекс, 1);
				}
			}

			// Запускаем следующий шаг в очереди, если последний шаг не был принудительным.
			// Таймеры в настоящее время будут вызывать свои полные обратные вызовы, что
			// исключим из очереди, но только если они были gotoEnd.
			if (удалить из очереди || !gotoEnd) {
				jQuery.dequeue(это, тип);
			}
		});
	},
	финиш: функция(тип) {
		если (тип!== ложь) {
			тип = тип || "FX";
		}
		верните this.each( function() {
			индекс вар,
				данные = dataPriv.get(это),
				очередь = данные[тип + «очередь»],
				крючки = данные [тип + «queueHooks» ],
				таймеры = jQuery.timers,
				длина = очередь? очередь.длина: 0;

			// Включаем флаг завершения для личных данных
			данные.финиш = правда;

			// Сначала очищаем очередь
			jQuery.queue(это, тип, []);

			if ( хуки && крючки.stop ) {
				ooks.stop.call(это, правда);
			}

			// Ищем все активные анимации и завершаем их
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					таймеры[индекс].anim.stop(истина);
					timers.splice(индекс, 1);
				}
			}

			// Ищем любые анимации в старой очереди и завершаем их
			for (индекс = 0; индекс <длина; индекс++) {
				if ( очередь[ индекс ] && очередь[ индекс ].finish ) {
					очередь[индекс].finish.call(это);
				}
			}

			// Отключаем флаг завершения
			удалить данные.закончить;
		});
	}
});

jQuery.each([ "переключить", "показать", "скрыть"], function( _i, name) {
	вар cssFn = jQuery.fn[имя];
	jQuery.fn[имя] = функция(скорость, замедление, обратный вызов) {
		скорость возврата == ноль || typeof скорость === "логическое" ?
			cssFn.apply(это, аргументы):
			this.animate( genFx( name, true ), скорость, замедление, обратный вызов );
	};
});

// Генерируем ярлыки для пользовательских анимаций
jQuery.each( {
	слайдВниз: genFx("показать"),
	слайдВверх: genFx("скрыть"),
	слайдToggle: genFx("переключить"),
	FadeIn: { opacity: "show" },
	FadeOut: { непрозрачность: "скрыть" },
	FadeToggle: { непрозрачность: "переключить" }
}, функция(имя, реквизит) {
	jQuery.fn[имя] = функция(скорость, замедление, обратный вызов) {
		return this.animate(реквизит, скорость, замедление, обратный вызов);
	};
});

jQuery.timers = [];
jQuery.fx.tick = функция() {
	вар таймер,
		я = 0,
		таймеры = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		таймер = таймеры [я];

		// Запускаем таймер и безопасно удаляем его по завершении (с возможностью внешнего удаления)
		if ( !timer() && timers[ i ] === таймер ) {
			timers.splice( i--, 1);
		}
	}

	если (!timers.length) {
		jQuery.fx.stop();
	}
	fxNow = не определено;
};

jQuery.fx.timer = функция(таймер) {
	jQuery.timers.push(таймер);
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = функция() {
	если (инПрогресс) {
		возвращаться;
	}

	вПрогресс = правда;
	расписание();
};

jQuery.fx.stop = функция() {
	вПрогресс = ноль;
};

jQuery.fx.speeds = {
	медленно: 600,
	быстро: 200,

	// Скорость по умолчанию
	_по умолчанию: 400
};


// На основе плагина Клинта Хелферса, с разрешения.
jQuery.fn.delay = функция (время, тип) {
	время = jQuery.fx? jQuery.fx.speeds[ время ] || время: время;
	тип = тип || "FX";

	return this.queue(type, function(next, хуки) {
		var timeout = window.setTimeout(следующий, время);
		хуки.стоп = функция() {
			window.clearTimeout(тайм-аут);
		};
	});
};


(функция() {
	var input = document.createElement("input"),
		select = document.createElement("выбрать"),
		opt = select.appendChild(document.createElement("опция"));

	input.type = "флажок";

	// Поддержка: только Android <= 4.3
	// Значение по умолчанию для флажка должно быть «включено»
	support.checkOn = input.value !== "";

	// Поддержка: только IE <= 11
	// Необходимо получить доступ к selectedIndex, чтобы выбрать параметры по умолчанию
	support.optSelected = opt.selected;

	// Поддержка: только IE <= 11
	// Ввод теряет свое значение после того, как становится радио
	input = document.createElement("вход");
	input.value = "т";
	input.type = "радио";
	support.radioValue = input.value === "t";
} )();


вар boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	атрибут: функция(имя, значение) {
		возврат доступа (это, jQuery.attr, имя, значение, аргументы.длина > 1);
	},

	RemoveAttr: функция(имя) {
		верните this.each( function() {
			jQuery.removeAttr(это, имя);
		});
	}
});

jQuery.extend( {
	attr: функция (элемент, имя, значение) {
		вар рет, крючки,
			nType = элемент.nodeType;

		// Не получать/устанавливать атрибуты в узлах текста, комментариев и атрибутов
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			возвращаться;
		}

		// Возврат к prop, если атрибуты не поддерживаются
		if ( typeof elem.getAttribute === "не определено") {
			вернуть jQuery.prop(элемент, имя, значение);
		}

		// Перехватчики атрибутов определяются версией в нижнем регистре
		// Захватываем необходимый хук, если он определен
		if ( nType !== 1 || !jQuery.isXMLDoc(elem) ) {
			хуки = jQuery.attrHooks[ name.toLowerCase() ] ||
				(jQuery.expr.match.bool.test(имя)? boolHook: не определено);
		}

		если (значение!== неопределенное) {
			если (значение === ноль) {
				jQuery.removeAttr(элемент, имя);
				возвращаться;
			}

			if ( хуки && "установлены" в хуки &&
				( ret =ooks.set(elem, value, name) ) !== не определено ) {
				вернуть возврат;
			}

			elem.setAttribute(имя, значение + "");
			возвращаемое значение;
		}

		if ( перехватчики && "get" в перехватчиках && ( ret =ooks.get(elem, name) ) !== null ) {
			вернуть возврат;
		}

		ret = jQuery.find.attr(элемент, имя);

		// Несуществующие атрибуты возвращают ноль, мы нормализуем их до неопределенных
		вернуть возврат == ноль? неопределенное: Рет;
	},

	attrHooks: {
		тип: {
			набор: функция (элемент, значение) {
				if ( !support.radioValue && значение === "радио" &&
					имяузла(элемент, "вход")) {
					вар вал = элемент.значение;
					elem.setAttribute("тип", значение);
					если (значение) {
						элемент.значение = значение;
					}
					возвращаемое значение;
				}
			}
		}
	},

	RemoveAttr: функция (элемент, значение) {
		имя вар,
			я = 0,

			// Имена атрибутов могут содержать пробельные символы, отличные от HTML.
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = значение && value.match(rnothtmlwhite);

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				элем.removeAttribute(имя);
			}
		}
	}
});

// Перехватчики для логических атрибутов
boolHook = {
	set: функция(элемент, значение, имя) {
		если (значение === ложь) {

			// Удалить логические атрибуты, если установлено значение false
			jQuery.removeAttr(элемент, имя);
		} еще {
			elem.setAttribute(имя, имя);
		}
		вернуть имя;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match(/\w+/g), function( _i, name) {
	var getter = attrHandle[имя] || jQuery.find.attr;

	attrHandle[имя] = функция(элемент, имя, isXML) {
		вар Рет, ручка,
			нижнее имя = name.toLowerCase();

		если ( !isXML ) {

			// Избегайте бесконечного цикла, временно удалив эту функцию из геттера
			дескриптор = attrHandle [нижний регистр];
			attrHandle [нижний регистр] = ret;
			ret = getter(elem, name, isXML)!= null?
				имя в нижнем регистре:
				нулевой;
			attrHandle [нижний регистр] = дескриптор;
		}
		вернуть возврат;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	реквизит: функция(имя, значение) {
		возврат доступа (это, jQuery.prop, имя, значение, аргументы.длина > 1);
	},

	RemoveProp: функция (имя) {
		верните this.each( function() {
			удалить это[ jQuery.propFix[имя] || имя ];
		});
	}
});

jQuery.extend( {
	опора: функция (элемент, имя, значение) {
		вар рет, крючки,
			nType = элемент.nodeType;

		// Не получать/устанавливать свойства узлов текста, комментариев и атрибутов
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			возвращаться;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc(elem) ) {

			// Исправляем имя и прикрепляем хуки
			имя = jQuery.propFix[имя] || имя;
			хуки = jQuery.propHooks[имя];
		}

		если (значение!== неопределенное) {
			if ( хуки && "установлены" в хуки &&
				( ret =ooks.set(elem, value, name) ) !== не определено ) {
				вернуть возврат;
			}

			return (элемент [имя] = значение);
		}

		if ( перехватчики && "get" в перехватчиках && ( ret =ooks.get(elem, name) ) !== null ) {
			вернуть возврат;
		}

		вернуть элемент [имя];
	},

	пропХуки: {
		tabIndex: {
			получить: функция (элемент) {

				// Поддержка: только IE <=9–11
				// elem.tabIndex не всегда возвращает
				// правильное значение, если оно не было установлено явно
				// Используйте правильное получение атрибутов (trac-12072)
				var tabindex = jQuery.find.attr(elem, "tabindex");

				если ( табиндекс ) {
					вернуть parseInt( tabindex, 10 );
				}

				если (
					rfocusable.test(elem.nodeName) ||
					rclickable.test(elem.nodeName) &&
					элемент.href
				) {
					вернуть 0;
				}

				возврат -1;
			}
		}
	},

	пропФикс: {
		"для": "htmlFor",
		"класс": "имякласса"
	}
});

// Поддержка: только IE <= 11
// Доступ к свойству selectedIndex
// заставляет браузер соблюдать выбранные настройки
// по опциону
// Геттер гарантирует, что выбран вариант по умолчанию
// когда в группе опций
// правило eslint «no-unused-expressions» отключено для этого кода
// так как он считает такие присоединения noop
если (!support.optSelected) {
	jQuery.propHooks.selected = {
		получить: функция (элемент) {

			/* eslint no-unused-expressions: "off" */

			вар родительский = elem.parentNode;
			если (родительский && родительский.parentNode) {
				родительский.parentNode.selectedIndex;
			}
			вернуть ноль;
		},
		набор: функция (элемент) {

			/* eslint no-unused-expressions: "off" */

			вар родительский = elem.parentNode;
			если (родитель) {
				родительский.выбранныйИндекс;

				если (parent.parentNode) {
					родительский.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"табИндекс",
	"Только чтение",
	"максимальная длина",
	"клеткаспейсинг",
	"клеткаПаддинг",
	"строкаSpan",
	"КолСпан",
	"использоватьКарту",
	"рамка",
	"contentEditable"
], функция() {
	jQuery.propFix[this.toLowerCase()] = это;
});




	// Удаление и свертывание пробелов в соответствии со спецификацией HTML
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	функция StripAndCollapse(значение) {
		var tokens = value.match(rnothtmlwhite) || [];
		return tokens.join( " " );
	}


функция getClass(элемент) {
	return elem.getAttribute && elem.getAttribute("класс" ) || "";
}

функция classToArray(значение) {
	если (Array.isArray(значение)) {
		возвращаемое значение;
	}
	if ( typeof value === "строка" ) {
		возвращаемое значение.match( rnothtmlwhite ) || [];
	}
	возвращаться [];
}

jQuery.fn.extend( {
	addClass: функция(значение) {
		вар ClassNames, Cur, CurValue, ClassName, я, FinalValue;

		если ( isFunction ( значение ) ) {
			верните this.each( function( j ) {
				jQuery(this).addClass(value.call(this, j, getClass(this)));
			});
		}

		ClassNames = ClassToArray(значение);

		если (имя классов.длина) {
			верните this.each( function() {
				curValue = getClass(это);
				cur = this.nodeType === 1 && ( " " + StripAndCollapse(curValue ) + " ");

				если (cur) {
					for ( я = 0; я <имя классов.длина; я++) {
						имя класса = имена классов [я];
						if ( cur.indexOf( " " + имя класса + " " ) < 0 ) {
							Cur += Имя класса + " ";
						}
					}

					// Назначать только в том случае, если они разные, чтобы избежать ненужного рендеринга.
					FinalValue = StripAndCollapse (cur);
					если (curValue!== FinalValue) {
						this.setAttribute("класс", FinalValue);
					}
				}
			});
		}

		верните это;
	},

	RemoveClass: функция (значение) {
		вар ClassNames, Cur, CurValue, ClassName, я, FinalValue;

		если ( isFunction ( значение ) ) {
			верните this.each( function( j ) {
				jQuery(this).removeClass(value.call(this, j, getClass(this)));
			});
		}

		если ( !arguments.length ) {
			вернуть this.attr("класс", "");
		}

		ClassNames = ClassToArray(значение);

		если (имя классов.длина) {
			верните this.each( function() {
				curValue = getClass(это);

				// Это выражение здесь для лучшей сжимаемости (см. addClass)
				cur = this.nodeType === 1 && ( " " + StripAndCollapse(curValue ) + " ");

				если (cur) {
					for ( я = 0; я <имя классов.длина; я++) {
						имя класса = имена классов [я];

						// Удаляем *все* экземпляры
						while (cur.indexOf( " " + имя класса + " " ) > -1 ) {
							cur = cur.replace( " " + имя класса + " ", " " );
						}
					}

					// Назначать только в том случае, если они разные, чтобы избежать ненужного рендеринга.
					FinalValue = StripAndCollapse (cur);
					если (curValue!== FinalValue) {
						this.setAttribute("класс", FinalValue);
					}
				}
			});
		}

		верните это;
	},

	toggleClass: функция(значение,stateVal) {
		вар имя класса, имя класса, я, я,
			тип = значение типа,
			isValidValue = тип === "строка" || Array.isArray(значение);

		если ( isFunction ( значение ) ) {
			верните this.each( function( i ) {
				jQuery( это ).toggleClass(
					value.call(это, я, getClass(это),stateVal),
					StateVal
				);
			});
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			вернуть состояниеVal? this.addClass(значение): this.removeClass(значение);
		}

		ClassNames = ClassToArray(значение);

		верните this.each( function() {
			если ( isValidValue ) {

				// Переключение имен отдельных классов
				self = jQuery(это);

				for ( я = 0; я <имя классов.длина; я++) {
					имя класса = имена классов [я];

					// Проверяем каждое заданное имя класса, список, разделенный пробелами
					если (self.hasClass(имя класса)) {
						self.removeClass(имя класса);
					} еще {
						self.addClass(имя класса);
					}
				}

			// Переключение имени всего класса
			} else if (значение === неопределенное || тип === "логическое" ) {
				Имя класса = getClass(это);
				если (имя класса) {

					// Сохраняем имя класса, если оно установлено
					dataPriv.set( this, "__className__", className );
				}

				// Если у элемента есть имя класса или нам передано `false`,
				// затем удаляем все имя класса (если оно было, то его сохранили выше).
				// В противном случае верните все, что было сохранено ранее (если есть),
				// возврат к пустой строке, если ничего не было сохранено.
				если ( this.setAttribute ) {
					this.setAttribute("класс",
						имя класса || значение === ложь?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		});
	},

	hasClass: функция (селектор) {
		вар имя класса, элемент,
			я = 0;

		className = " " + селектор + " ";
		while ( ( elem = this[ i++ ] ) ) {
			если ( elem.nodeType === 1 &&
				( " " + StripAndCollapse( getClass(elem ) ) + " " ).indexOf( className ) > -1 ) {
				вернуть истину;
			}
		}

		вернуть ложь;
	}
});




вар rreturn = /\r/g;

jQuery.fn.extend( {
	значение: функция(значение) {
		вар хуки, ret, valueIsFunction,
			элем = это [0];

		если ( !arguments.length ) {
			если ( элем ) {
				перехватчики = jQuery.valHooks[elem.type] ||
					jQuery.valHooks[elem.nodeName.toLowerCase()];

				if ( крючки &&
					"получить" в крючках &&
					( ret =ooks.get(elem, "value" ) ) !== не определено
				) {
					вернуть возврат;
				}

				ret = элемент.значение;

				// Обработка наиболее распространенных строковых случаев
				if ( typeof ret === "строка" ) {
					return ret.replace(rreturn, "");
				}

				// Обрабатываем случаи, когда значение равно null/undef или число
				вернуть возврат == ноль? "" : в отставку;
			}

			возвращаться;
		}

		значениеIsFunction = isFunction (значение);

		верните this.each( function( i ) {
			вар вал;

			если ( this.nodeType !== 1 ) {
				возвращаться;
			}

			если (valueIsFunction) {
				val = value.call(this, i, jQuery(this).val() );
			} еще {
				вал = значение;
			}

			// Обрабатывать значение null/undefined как ""; конвертировать числа в строку
			если (значение == ноль) {
				вал = "";

			} else if ( typeof val === "number" ) {
				вал += "";

			} Еще если (Array.isArray(значение)) {
				val = jQuery.map(значение, функция(значение) {
					возвращаемое значение == ноль? "" : значение + "";
				});
			}

			перехватчики = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// Если set возвращает неопределенное значение, возвращаемся к обычным настройкам
			if ( !hooks || !( "set" в крючках) ||ooks.set(this, val, "value" ) === undefined ) {
				это.значение = значение;
			}
		});
	}
});

jQuery.extend( {
	valHooks: {
		вариант: {
			получить: функция (элемент) {

				var val = jQuery.find.attr(elem, "value");
				вернуть значение!= ноль?
					вал:

					// Поддержка: только IE <= 10–11
					// option.text выдает исключения (trac-14686, trac-14858)
					// Удаление и свертывание пробелов
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					StripAndCollapse(jQuery.text(elem));
			}
		},
		выбирать: {
			получить: функция (элемент) {
				значение переменной, опция, я,
					параметры = элемент.опции,
					индекс = элемент.выбранныйиндекс,
					one = elem.type === "выберите один",
					значения = один? нулевой : [],
					максимум = один? индекс + 1: options.length;

				если (индекс <0) {
					я = Макс;

				} еще {
					я = один? индекс: 0;
				}

				// Проходим по всем выбранным параметрам
				для ( ; я < макс; я++ ) {
					опция = опции [я];

					// Поддержка: только IE <=9
					// IE8-9 не обновляет выбранное после сброса формы (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Не возвращать опции, которые отключены или находятся в отключенной группе опций
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Получаем конкретное значение для опции
						значение = jQuery(опция).val();

						// Нам не нужен массив для одного выбора
						если один ) {
							возвращаемое значение;
						}

						// Множественный выбор возвращает массив
						значения.push(значение);
					}
				}

				возвращаемые значения;
			},

			набор: функция (элемент, значение) {
				вар optionSet, опция,
					параметры = элемент.опции,
					значения = jQuery.makeArray(значение),
					я = параметры.длина;

				в то время как я-- ) {
					опция = опции [я];

					/* eslint-disable no-cond-assign */

					если ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get(опция), значения) > -1
					) {
						optionSet = правда;
					}

					/* eslint-enable no-cond-assign */
				}

				// Заставляем браузеры вести себя согласованно, если установлено несовпадающее значение
				если (!optionSet) {
					элемент.выбранныйИндекс = -1;
				}
				возвращаемые значения;
			}
		}
	}
});

// Радиоприемники и чекбоксы, метод получения/установки
jQuery.each([ "радио", "флажок" ], function() {
	jQuery.valHooks[ это ] = {
		набор: функция (элемент, значение) {
			если (Array.isArray(значение)) {
				return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
			}
		}
	};
	если (!support.checkOn) {
		jQuery.valHooks[this].get = function(elem) {
			return elem.getAttribute("значение") === null? «включено»: elem.value;
		};
	}
});




// Возвращаем jQuery для включения только атрибутов
вар местоположение = window.location;

var nonce = {guid: Date.now() };

вар rquery = ( /\?/ );



// Кроссбраузерный анализ XML
jQuery.parseXML = функция(данные) {
	вар xml, parserErrorElem;
	if ( !data || тип данных !== "строка") {
		вернуть ноль;
	}

	// Поддержка: только IE 9–11
	// IE выдает ошибку parseFromString с недопустимым вводом.
	пытаться {
		xml = (новое окно.DOMParser()).parseFromString(data, "text/xml");
	} поймать ( е ) {}

	parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Неверный XML: " + (
			парсерErrorElem?
				jQuery.map(parserErrorElem.childNodes, function(el) {
					вернуть эл.текстСодержимое;
				} ).join( "\n") :
				данные
		) );
	}
	вернуть XML;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = функция (е) {
		е.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	триггер: функция (событие, данные, элем, onlyHandlers) {

		var i, cur, tmp, bubbleType, ontype, handle, специальный, LastElement,
			eventPath = [ элемент || документ ],
			тип = hasOwn.call(событие, «тип»)? event.type : событие,
			пространства имен = hasOwn.call(событие, «пространство имен»)? event.namespace.split( "." ): [];

		Cur = LastElement = tmp = Elem = Elem || документ;

		// Не выполнять события на текстовых узлах и узлах комментариев
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			возвращаться;
		}

		// фокус/размытие преобразуется в focusin/out; убедиться, что мы не увольняем их прямо сейчас
		if (rfocusMorph.test(type + jQuery.event.triggered)) {
			возвращаться;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Триггер в пространстве имен; создайте регулярное выражение, соответствующее типу события в handle()
			пространства имен = type.split( "." );
			тип = пространства имен.shift();
			пространства имен.сорт();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Вызывающий объект может передать объект jQuery.Event, Object или просто строку типа события
		событие = событие [jQuery.expando]?
			событие :
			новый jQuery.Event(type, typeof event === "object" && event);

		// Битовая маска триггера: & 1 для собственных обработчиков; & 2 для jQuery (всегда верно)
		event.isTrigger = onlyHandlers? 2:3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ):
			нулевой;

		// Очистка события на случай его повторного использования
		event.result = не определено;
		если (!event.target) {
			event.target = элемент;
		}

		// Клонируем все входящие данные и добавляем событие, создавая список аргументов обработчика
		данные = данные == ноль?
			[ событие ] :
			jQuery.makeArray(данные, [событие]);

		// Разрешить специальным событиям выходить за пределы линий
		специальный = jQuery.event.special[тип] || {};
		if ( !onlyHandlers &&special.trigger &&special.trigger.apply(elem, data) === false ) {
			возвращаться;
		}

		// Заранее определите путь распространения событий в соответствии со спецификацией событий W3C (trac-9951)
		// Поднимемся к документу, затем к окну; следите за глобальным владельцемDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow(elem) ) {

			bubbleType = Special.delegateType || тип;
			if ( !rfocusMorph.test( bubbleType + type )) {
				Cur = cur.parentNode;
			}
			for (; cur; cur = cur.parentNode) {
				eventPath.push(cur);
				ТМП = Кур;
			}

			// Добавляем окно только в том случае, если мы добрались до документа (например, не простого объекта или отдельного DOM)
			if ( tmp === ( elem.ownerDocument || документ )) {
				eventPath.push(tmp.defaultView || tmp.parentWindow || окно);
			}
		}

		// Обработчики огня на пути к событию
		я = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
			последнийЭлемент = кур;
			event.type = я > 1?
				Тип пузыря:
				специальный.bindType || тип;

			// обработчик jQuery
			handle = ( dataPriv.get(cur, "events") || Object.create(null) )[event.type] &&
				dataPriv.get(cur, "дескриптор");
			если ( дескриптор ) {
				handle.apply(cur, данные);
			}

			// Собственный обработчик
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && AcceptData(cur ) ) {
				event.result = handle.apply(cur, data);
				если ( event.result === false ) {
					событие.preventDefault();
				}
			}
		}
		event.type = тип;

		// Если никто не запретил действие по умолчанию, сделайте это сейчас
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			если ( ( !special._default ||
				Special._default.apply( eventPath.pop(), data ) === false ) &&
				принять данные (элемент) ) {

				// Вызов собственного метода DOM для цели с тем же именем, что и у события.
				// Не выполнять действия по умолчанию в окне, там должны быть глобальные переменные (trac-6170)
				if ( ontype && isFunction(elem[type]) && !isWindow(elem) ) {

					// Не запускать повторно событие onFOO, когда мы вызываем его метод FOO()
					tmp = элемент [ontype];

					если ( тмп ) {
						элемент [ontype] = ноль;
					}

					// Предотвращаем повторный запуск того же события, поскольку мы уже всплыли выше
					jQuery.event.triggered = тип;

					если ( event.isPropagationStopped() ) {
						LastElement.addEventListener(тип, stopPropagationCallback);
					}

					элемент [тип]();

					если ( event.isPropagationStopped() ) {
						LastElement.removeEventListener(тип, stopPropagationCallback);
					}

					jQuery.event.triggered = не определено;

					если ( тмп ) {
						элемент [ontype] = tmp;
					}
				}
			}
		}

		вернуть событие.результат;
	},

	// Совмещение донорского события для имитации другого
	// Используется только для событий `focus(in | out)`
	симулировать: функция (тип, элемент, событие) {
		вар е = jQuery.extend(
			новый jQuery.Event(),
			событие,
			{
				тип: тип,
				isSimulated: правда
			}
		);

		jQuery.event.trigger(e, null, elem);
	}

});

jQuery.fn.extend( {

	триггер: функция(тип, данные) {
		верните this.each( function() {
			jQuery.event.trigger(тип, данные, это);
		});
	},
	триггерHandler: функция (тип, данные) {
		вар элем = это [0];
		если ( элем ) {
			return jQuery.event.trigger(тип, данные, элемент, правда);
		}
	}
});


вар
	рбрекет = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

функция buildParams(префикс, объект, традиционный, добавить) {
	имя переменной;

	если (Array.isArray(obj)) {

		// Сериализация элемента массива.
		jQuery.each(объект, функция(я, v) {
			if (традиционный || rbracket.test(префикс)) {

				// Считаем каждый элемент массива скаляром.
				добавить(префикс, v);

			} еще {

				// Элемент не скалярный (массив или объект), закодируйте его числовой индекс.
				buildParams(
					префикс + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					в,
					традиционный,
					добавлять
				);
			}
		});

	} else if ( !traditional && toType(obj) === "object") {

		// Сериализация элемента объекта.
		for (имя в объекте) {
			buildParams( префикс + "[" + имя + "]", obj[имя], традиционный, добавить);
		}

	} еще {

		// Сериализация скалярного элемента.
		добавить (префикс, объект);
	}
}

// Сериализуем массив элементов формы или набор
// ключ/значения в строку запроса
jQuery.param = function(a, традиционный) {
	префикс var,
		с = [],
		добавить = функция (ключ, значениеИлиФункция) {

			// Если value — функция, вызвать ее и использовать возвращаемое значение
			значение вар = isFunction (valueOrFunction)?
				значениеИлиФункция():
				значениеИлиФункция;

			s[ s.length ] = encodeURIComponent(key) + "=" +
				encodeURIComponent(значение == null? "": значение);
		};

	если ( а == ноль ) {
		возвращаться "";
	}

	// Если был передан массив, предположим, что это массив элементов формы.
	if ( Array.isArray(a) || ( a.jquery && !jQuery.isPlainObject(a) ) ) {

		// Сериализация элементов формы
		jQuery.each(а, функция() {
			добавить(это.имя, это.значение);
		});

	} еще {

		// Если традиционный, кодируйте «старым» способом (способ 1.3.2 или старше
		// сделал это), в противном случае параметры кодируются рекурсивно.
		for (префикс в a) {
			buildParams(префикс, [префикс], традиционный, добавить);
		}
	}

	// Возвращаем результирующую сериализацию
	вернуть s.join( "&");
};

jQuery.fn.extend( {
	сериализовать: функция() {
		return jQuery.param(this.serializeArray());
	},
	сериализационныйArray: функция() {
		верните this.map( function() {

			// Можно добавить propHook для «элементов» для фильтрации или добавления элементов формы
			var elements = jQuery.prop(this, "elements");
			вернуть элементы? jQuery.makeArray(elements): это;
		} ).filter( function() {
			тип вар = this.type;

			// Используйте .is( ":disabled" ), чтобы fieldset[disabled] работал
			вернуть this.name && !jQuery(this).is(":disabled") &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test(тип));
		} ).map( function( _i, elem ) {
			var val = jQuery(this).val();

			если (значение == ноль) {
				вернуть ноль;
			}

			если ( Array.isArray( val ) ) {
				return jQuery.map(значение, функция(значение) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				});
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).получать();
	}
});


вар
	r20 = /%20/г,
	хеш = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/мг,

	// trac-7653, trac-8125, trac-8152: обнаружение локального протокола
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	рпротокол = /^\/\//,

	/* Предварительные фильтры
	 * 1) Они полезны для введения пользовательских типов данных (пример см. в ajax/jsonp.js).
	 * 2) Их называют:
	 * - ПРЕЖДЕ ЧЕМ просить транспорт
	 * - ПОСЛЕ сериализации параметров (s.data — это строка, если s.processData имеет значение true)
	 * 3) ключ — это тип данных
	 * 4) можно использовать общий символ «*».
	 * 5) выполнение начнется с транспортного типа данных, а ЗАТЕМ продолжится до «*», если необходимо.
	 */
	префильтры = {},

	/* Транспортирует привязки
	 * 1) ключ — это тип данных
	 * 2) можно использовать общий символ «*».
	 * 3) выбор начнется с типа транспортных данных, а ЗАТЕМ при необходимости перейдите к «*».
	 */
	транспорты = {},

	// Избегайте последовательности символов комментария-пролога (trac-10098); должен успокоить ворс и избежать сжатия
	allTypes = "*/".concat( "*" ),

	// Тег привязки для анализа происхождения документа
	originAnchor = document.createElement( "a");

originAnchor.href = location.href;

// Базовый «конструктор» для jQuery.ajaxPrefilter и jQuery.ajaxTransport
функция addToPrefiltersOrTransports(структура) {

	// dataTypeExpression не является обязательным и по умолчанию имеет значение «*»
	возвращаемая функция (dataTypeExpression, func) {

		if ( typeof dataTypeExpression !== "строка" ) {
			функция = выражениетипа данных;
			DataTypeExpression = "*";
		}

		вар тип данных,
			я = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		если ( isFunction( func ) ) {

			// Для каждого типа данных в dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Добавляем в начало, если требуется
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice(1) || "*";
					( структура[ тип данных ] = структура [ тип данных ] || [] ).unshift( func );

				// В противном случае добавляем
				} еще {
					( структура[ тип данных ] = структура [ тип данных ] || [] ).push( func );
				}
			}
		}
	};
}

// Базовая функция проверки предфильтров и транспортных средств
функция InspectPrefiltersOrTransports (структура, параметры, originalOptions, jqXHR) {

	вар проверен = {},
		ищуТранспорт = (структура === транспорты);

	функция проверки (тип данных) {
		выбранная переменная;
		проверено [тип данных] = правда;
		jQuery.each( структура[ dataType ] || [], function( _, prefilterOrFactory ) {
			вар dataTypeOrTransport = prefilterOrFactory (options, originalOptions, jqXHR);
			if ( typeof dataTypeOrTransport === "строка" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift(dataTypeOrTransport);
				проверить (тип данныхилитранспорт);
				вернуть ложь;
			} else if (ищу транспорт) {
				возврат! (выбрано = dataTypeOrTransport);
			}
		});
		вернуть выбранное;
	}

	return check( options.dataTypes[0 ]) || !inspected[ "*" ] && проверить( "*" );
}

// Специальное расширение для опций ajax
// который принимает «плоские» опции (не подлежит глубокому расширению)
// Исправляет trac-9887
функция ajaxExtend(цель, источник) {
	ключ вар, глубокий,
		FlatOptions = jQuery.ajaxSettings. FlatOptions || {};

	for (ключ в src) {
		if ( src[ ключ ] !== не определено ) {
			( FlatOptions[ключ]? Цель: (глубокий || (глубокий = {})))[ключ] = src[ключ];
		}
	}
	если ( глубоко ) {
		jQuery.extend(истина, цель, глубина);
	}

	возвратная цель;
}

/* Обрабатывает ответы на запрос ajax:
 * - находит правильный тип данных (посредник между типом контента и ожидаемым типом данных)
 * - возвращает соответствующий ответ
 */
функция ajaxHandleResponses(s, jqXHR, ответы) {

	var ct, тип, FinalDataType, FirstDataType,
		содержимое = s.contents,
		типы данных = s.dataTypes;

	// Удалить автоматический тип данных и получить тип контента в процессе
	while ( dataTypes[ 0 ] === "*" ) {
		Типы данных.shift();
		если ( ct === не определено ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Тип контента");
		}
	}

	// Проверяем, имеем ли мы дело с известным типом контента
	если ( ct ) {
		for (введите содержимое) {
			if ( содержимое [ тип ] && содержимое [ тип ].test( ct ) ) {
				dataTypes.unshift(тип);
				перерыв;
			}
		}
	}

	// Проверяем, есть ли у нас ответ на ожидаемый тип данных
	if (dataTypes[0] в ответах) {
		FinalDataType = DataTypes [0];
	} еще {

		// Попробуйте конвертируемые типы данных
		for (введите ответы) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				FinalDataType = тип;
				перерыв;
			}
			если (!firstDataType) {
				ПервыйТипДанных = тип;
			}
		}

		// Или просто используйте первый
		FinalDataType = FinalDataType || ПервыйТипДанных;
	}

	// Если мы нашли тип данных
	// При необходимости добавляем dataType в список
	// и возвращаем соответствующий ответ
	если (finalDataType) {
		if (finalDataType!== dataTypes[0]) {
			dataTypes.unshift(finalDataType);
		}
		вернуть ответы [finalDataType];
	}
}

/* Цепочка преобразований с учетом запроса и исходного ответа
 * Также устанавливает поля responseXXX в экземпляре jqXHR.
 */
функция ajaxConvert(s, ответ, jqXHR, isSuccess) {
	var conv2, текущий, conv, tmp, предыдущая,
		конвертеры = {},

		// Работаем с копией типов данных на случай, если нам понадобится изменить ее для преобразования
		dataTypes = s.dataTypes.slice();

	// Создаем карту конвертеров с клавишами в нижнем регистре
	если (типы данных[1]) {
		for (conv в s.converters) {
			преобразователи[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	текущий = dataTypes.shift();

	// Преобразование в каждый последовательный тип данных
	пока (текущий) {

		если ( s.responseFields[текущий]) {
			jqXHR[ s.responseFields[текущий]] = ответ;
		}

		// Применяем dataFilter, если он предусмотрен
		if ( !prev && isSuccess && s.dataFilter ) {
			ответ = s.dataFilter(ответ, s.dataType);
		}

		предыдущий = текущий;
		текущий = dataTypes.shift();

		если ( текущий ) {

			// Работать нужно только в том случае, если текущий тип данных не является автоматическим
			если (текущий === "*" ) {

				текущий = предыдущий;

			// Преобразование ответа, если предыдущий тип данных не является автоматическим и отличается от текущего
			} else if (prev !== "*" && prev !== current ) {

				// Ищем прямой преобразователь
				conv = преобразователи[ предыдущая + " " + текущая ] || преобразователи[ "* " + ток];

				// Если ничего не найдено, ищем пару
				если ( !conv ) {
					for ( conv2 в конвертерах ) {

						// Если conv2 выводит текущий
						tmp = conv2.split( " " );
						если ( tmp[ 1 ] === текущий ) {

							// Если предыдущее можно преобразовать в принятый ввод
							conv = преобразователи[ предыдущая + " " + tmp[ 0 ] ] ||
								преобразователи[ "* " + tmp[0]];
							если (услов) {

								// Конденсационные преобразователи эквивалентности
								если (услов === верно) {
									conv = конвертеры[ conv2 ];

								// В противном случае вставьте промежуточный тип данных
								} else if (converters[conv2] !== true ) {
									ток = tmp[0];
									dataTypes.unshift(tmp[1]);
								}
								перерыв;
							}
						}
					}
				}

				// Применяем конвертер (если нет эквивалентности)
				если (услов!== верно) {

					// Если ошибкам не разрешено всплывать, перехватываем и возвращаем их
					if ( conv && s.throws ) {
						ответ = conv(ответ);
					} еще {
						пытаться {
							ответ = conv(ответ);
						} поймать ( е ) {
							возвращаться {
								состояние: "ошибка парсера",
								ошибка: конв? e : "Нет преобразования из " + предыдущая + " в " + текущая
							};
						}
					}
				}
			}
		}
	}

	return {состояние: «успех», данные: ответ};
}

jQuery.extend( {

	// Счетчик для хранения количества активных запросов
	активный: 0,

	// Кэш заголовка Last-Modified для следующего запроса
	Последнее изменение: {},
	этаг: {},

	ajaxSettings: {
		URL: location.href,
		тип: «ПОЛУЧИТЬ»,
		isLocal: rlocalProtocol.test(location.protocol),
		глобальный: правда,
		данные процесса: правда,
		асинхронный: правда,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		тайм-аут: 0,
		данные: ноль,
		Тип данных: нуль,
		имя пользователя: ноль,
		пароль: нулевой,
		кеш: нулевой,
		выдает: ложь,
		традиционный: ложный,
		заголовки: {},
		*/

		принимает: {
			"*": все типы,
			текст: "текст/обычный",
			HTML: "текст/html",
			xml: «приложение/xml, текст/xml»,
			json: «приложение/json, текст/javascript»
		},

		содержание: {
			xml: /\bxml\b/,
			HTML: /\bhtml/,
			json: /\bjson\b/
		},

		поля ответа: {
			xml: «ответXML»,
			текст: "текст ответа",
			json: "ответJSON"
		},

		// Преобразователи данных
		// Ключи разделяют исходный (или общий "*") и целевой типы одним пробелом
		конвертеры: {

			// Конвертируем что-либо в текст
			"* текст": строка,

			// Текст в HTML (истина = без преобразования)
			«текстовый HTML»: правда,

			// Оцениваем текст как выражение json
			«текст json»: JSON.parse,

			// Анализируем текст как XML
			«текстовый XML»: jQuery.parseXML
		},

		// Для опций, которые не должны быть глубоко расширены:
		// вы можете добавить сюда свои собственные параметры, если
		// и когда вы создаете тот, которого не должно быть
		// глубокое расширение (см. ajaxExtend)
		FlatOptions: {
			URL: правда,
			контекст: правда
		}
	},

	// Создает полноценный объект настроек в цель
	// с полями ajaxSettings и settings.
	// Если цель опущена, записывается в ajaxSettings.
	ajaxSetup: функция (цель, настройки) {
		вернуть настройки?

			// Создание объекта настроек
			ajaxExtend( ajaxExtend(target, jQuery.ajaxSettings), настройки):

			// Расширение настроек ajax
			ajaxExtend(jQuery.ajaxSettings, цель);
	},

	ajaxPrefilter: addToPrefiltersOrTransports(префильтры),
	ajaxTransport: addToPrefiltersOrTransports(транспорты),

	// Основной метод
	ajax: функция (URL, параметры) {

		// Если URL-адрес является объектом, имитируем подпись версии до 1.5
		if ( typeof url === "объект" ) {
			варианты = URL;
			URL = неопределенный;
		}

		// Принудительно сделать параметры объектом
		опции = опции || {};

		вар транспорт,

			// URL без параметра антикеширования
			кешURL,

			// Заголовки ответа
			ответHeadersString,
			заголовки ответа,

			// дескриптор тайм-аута
			таймаутТаймер,

			// Очистка URL-адреса var
			urlAnchor,

			// Состояние запроса (становится ложным при отправке и истинным после завершения)
			завершенный,

			// Чтобы узнать, должны ли отправляться глобальные события
			огоньГлобалс,

			// Переменная цикла
			я,

			// некэшированная часть URL
			некэшированный,

			// Создаём окончательный объект опций
			s = jQuery.ajaxSetup({}, параметры),

			// Контекст обратных вызовов
			callbackContext = s.context || с,

			// Контекстом для глобальных событий является callbackContext, если это узел DOM или коллекция jQuery.
			globalEventContext = s.context &&
				(callbackContext.nodeType || callbackContext.jquery)?
				jQuery (контекст обратного вызова):
				jQuery.событие,

			// Отсрочки
			отложенный = jQuery.Deferred(),
			CompleteDeferred = jQuery.Callbacks("однократная память"),

			// Обратные вызовы, зависящие от статуса
			statusCode = s.statusCode || {},

			// Заголовки (они отправляются все сразу)
			RequestHeaders = {},
			requestHeadersNames = {},

			// Сообщение об отмене по умолчанию
			стрАборт = "отменено",

			// Поддельный xhr
			jqXHR = {
				готовое состояние: 0,

				// При необходимости создает хеш-таблицу заголовков
				getResponseHeader: функция (ключ) {
					вар совпадение;
					если ( завершено ) {
						если (!responseHeaders) {
							responseHeaders = {};
							while ( ( match = rheaders.exec(responseHeadersString )) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat(соответствие[2]);
							}
						}
						match = responseHeaders[key.toLowerCase() + ""];
					}
					возврат совпадения == ноль? ноль: match.join( ", ");
				},

				// Необработанная строка
				getAllResponseHeaders: функция() {
					возврат завершен? responseHeadersString: ноль;
				},

				// Кэширует заголовок
				setRequestHeader: функция (имя, значение) {
					если (завершено == ноль) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || имя;
						requestHeaders[имя] = значение;
					}
					верните это;
				},

				// Переопределяет заголовок типа содержимого ответа
				overrideMimeType: функция (тип) {
					если (завершено == ноль) {
						s.mimeType = тип;
					}
					верните это;
				},

				// Обратные вызовы, зависящие от статуса
				statusCode: функция (карта) {
					вар-код;
					если (карта) {
						если ( завершено ) {

							// Выполняем соответствующие обратные вызовы
							jqXHR.always(карта[jqXHR.status]);
						} еще {

							// Ленивое добавление новых обратных вызовов таким образом, чтобы сохранить старые
							for (код на карте) {
								statusCode[код] = [statusCode[код], карта[код]];
							}
						}
					}
					верните это;
				},

				// Отменяем запрос
				прерывание: функция (statusText) {
					вар FinalText = statusText || стрАборт;
					если ( транспорт ) {
						Transport.abort(finalText);
					}
					готово (0, окончательный текст);
					верните это;
				}
			};

		// Прикрепляем отсрочки
		отложенное.обещание(jqXHR);

		// Добавляем протокол, если он не указан (его могут ожидать префильтры)
		// Обработка ложного URL-адреса в объекте настроек (trac-10093: согласованность со старой подписью)
		// Мы также используем параметр url, если он доступен
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace(rprotocol, location.protocol + "//");

		// Опция метода псевдонима для ввода согласно билету trac-12004
		s.type = options.method || параметры.тип || с.метод || тип с.;

		// Извлекаем список типов данных
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// Междоменный запрос допустим, если источник не соответствует текущему источнику.
		если ( s.crossDomain == null ) {
			urlAnchor = document.createElement("a");

			// Поддержка: IE <= 8–11, Edge 12–15
			// IE выдает исключение при доступе к свойству href, если URL-адрес неверен,
			// например http://example.com:80x/
			пытаться {
				urlAnchor.href = s.url;

				// Поддержка: только IE <= 8–11
				// Свойство хоста привязки установлено неправильно, если s.url является относительным
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} поймать ( е ) {

				// Если при анализе URL произошла ошибка, предположим, что это перекрестный домен,
				// он может быть отклонен транспортом, если он недействителен
				s.crossDomain = правда;
			}
		}

		// Преобразуем данные, если они еще не являются строкой
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param(s.data, s.traditional);
		}

		// Применяем предварительные фильтры
		InspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

		// Если запрос был прерван внутри префильтра, остановимся на этом
		если ( завершено ) {
			вернуть jqXHR;
		}

		// На данный момент мы можем запускать глобальные события, если нас об этом попросят
		// Не запускать события, если jQuery.event не определен в сценарии использования AMD (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Следим за новым набором запросов
		if (fireGlobals && jQuery.active++ === 0) {
			jQuery.event.trigger("ajaxStart");
		}

		// Тип заглавными буквами
		s.type = s.type.toUpperCase();

		// Определяем, есть ли в запросе контент
		s.hasContent = !rnoContent.test(s.type);

		// Сохраняем URL на случай, если мы поиграем с If-Modified-Since
		// и/или заголовок If-None-Match позже
		// Удаляем хеш, чтобы упростить манипулирование URL-адресами
		кэшURL = s.url.replace(rhash, "");

		// Дополнительные параметры обработки запросов без содержимого
		если (!s.hasContent) {

			// Запоминаем хеш, чтобы можно было вернуть его обратно
			некэшированный = s.url.slice(cacheURL.length);

			// Если данные доступны и должны быть обработаны, добавьте данные в URL
			if ( s.data && ( s.processData || typeof s.data === "string" )) {
				кэшURL += ( rquery.test(cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: удалить данные, чтобы они не использовались при повторной попытке
				удалить s.data;
			}

			// При необходимости добавляем или обновляем параметр антикэширования
			если ( s.cache === ложь ) {
				кэшURL = кэшURL.replace(rantiCache, "$1");
				uncached = ( rquery.test(cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					без кэширования;
			}

			// Помещаем хеш и антикеш на запрошенный URL (gh-1732)
			s.url = кэшURL + некэшированный;

		// Измените «%20» на «+», если это закодированное содержимое тела (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace(r20, "+");
		}

		// Устанавливаем заголовок If-Modified-Since и/или If-None-Match, если в режиме ifModified.
		если ( s.ifModified ) {
			если (jQuery.lastModified[cacheURL]) {
				jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
			}
			если (jQuery.etag[cacheURL]) {
				jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
			}
		}

		// Устанавливаем правильный заголовок, если данные отправляются
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader("Тип контента", s.contentType);
		}

		// Устанавливаем заголовок Accepts для сервера в зависимости от dataType
		jqXHR.setRequestHeader(
			"Принимать",
			s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ):
				s.accepts[ "*" ]
		);

		// Проверка наличия заголовков
		for (я в s.headers) {
			jqXHR.setRequestHeader(i, s.headers[i]);
		}

		// Разрешить пользовательские заголовки/миметипы и раннее прерывание
		если ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || завершено )) {

			// Прерываем, если это еще не сделано, и возвращаемся
			вернуть jqXHR.abort();
		}

		// Прерывание больше не является отменой
		strAbort = "прервать";

		// Устанавливаем обратные вызовы на отложенные вызовы
		CompleteDeferred.add(s.complete);
		jqXHR.done(с.успех);
		jqXHR.fail(s.error);

		// Получить транспорт
		транспорт = InspectPrefiltersOrTransports(транспорты, s, параметры, jqXHR);

		// Если транспорта нет, мы автоматически прерываем
		если ( !транспорт ) {
			Done(-1, «Нет транспорта»);
		} еще {
			jqXHR.readyState = 1;

			// Отправляем глобальное событие
			если (fireGlobals) {
				globalEventContext.trigger("ajaxSend", [jqXHR, s]);
			}

			// Если запрос был прерван внутри ajaxSend, остановимся на этом
			если ( завершено ) {
				вернуть jqXHR;
			}

			// Тайм-аут
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort("тайм-аут");
				}, с.тайм-аут);
			}

			пытаться {
				завершено = ложь;
				Transport.send(заголовки запроса, готово);
			} поймать ( е ) {

				// Повторно создаем исключения после завершения
				если ( завершено ) {
					бросить е;
				}

				// Распространяем другие как результаты
				готово(-1, е);
			}
		}

		// Обратный вызов, когда все будет сделано
		функция сделана (статус, NativeStatusText, ответы, заголовки) {
			var isSuccess, успех, ошибка, ответ, изменено,
				statusText = роднойStatusText;

			// Игнорируем повторные вызовы
			если ( завершено ) {
				возвращаться;
			}

			завершено = правда;

			// Очистить таймаут, если он существует
			если (таймауттаймер) {
				window.clearTimeout(таймаутТаймер);
			}

			// Разыменование транспорта для ранней сборки мусора
			// (независимо от того, как долго будет использоваться объект jqXHR)
			транспорт = не определено;

			// Кэшируем заголовки ответов
			responseHeadersString = заголовки || "";

			// Устанавливаем готовое состояние
			jqXHR.readyState = статус > 0? 4:0;

			// Определяем, успешно ли
			isSuccess = статус >= 200 && статус < 300 || статус === 304;

			// Получаем данные ответа
			если (ответы) {
				ответ = ajaxHandleResponses(s, jqXHR, ответы);
			}

			// Используйте конвертер noop для отсутствующего скрипта, но не для jsonp
			если ( !isSuccess &&
				jQuery.inArray("script", s.dataTypes) > -1 &&
				jQuery.inArray("json", s.dataTypes) <0) {
				s.converters[ "текстовый скрипт"] = function() {};
			}

			// Преобразование несмотря ни на что (таким образом поля ответаXXX всегда устанавливаются)
			ответ = ajaxConvert(s, ответ, jqXHR, isSuccess);

			// В случае успеха обрабатываем цепочку типов
			если ( isSuccess ) {

				// Устанавливаем заголовок If-Modified-Since и/или If-None-Match, если в режиме ifModified.
				если ( s.ifModified ) {
					модифицированный = jqXHR.getResponseHeader("Последнее изменение");
					если (изменено) {
						jQuery.lastModified[cacheURL] = изменено;
					}
					модифицированный = jqXHR.getResponseHeader("etag");
					если (изменено) {
						jQuery.etag[cacheURL] = изменено;
					}
				}

				// если нет контента
				if (status === 204 || s.type === "HEAD") {
					statusText = "нет контента";

				// если не изменено
				} еще если (статус === 304) {
					statusText = "не изменено";

				// Если у нас есть данные, давайте их преобразуем
				} еще {
					статусТекст = ответ.состояние;
					успех = ответ.данные;
					ошибка = ответ.ошибка;
					isSuccess =! ошибка;
				}
			} еще {

				// Извлекаем ошибку из statusText и нормализуем ее, чтобы она не прерывалась
				ошибка = статусТекст;
				если (статус || !statusText) {
					статусТекст = "ошибка";
					если (статус <0) {
						статус = 0;
					}
				}
			}

			// Устанавливаем данные для поддельного объекта xhr
			jqXHR.status = статус;
			jqXHR.statusText = (nativeStatusText || statusText) + "";

			// Успех/Ошибка
			если ( isSuccess ) {
				deferred.resolveWith(callbackContext, [успех, statusText, jqXHR]);
			} еще {
				deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
			}

			// Обратные вызовы, зависящие от статуса
			jqXHR.statusCode(statusCode);
			кодстатуса = не определено;

			если (fireGlobals) {
				globalEventContext.trigger(isSuccess? "ajaxSuccess": "ajaxError",
					[ jqXHR, s, isSuccess ? успех: ошибка]);
			}

			// Полный
			CompleteDeferred.fireWith(callbackContext, [jqXHR, statusText]);

			если (fireGlobals) {
				globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

				// Обработка глобального счетчика AJAX
				если ( !( --jQuery.active )) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		вернуть jqXHR;
	},

	getJSON: функция (URL, данные, обратный вызов) {
		return jQuery.get(url, data, обратный вызов, "json");
	},

	getScript: функция (URL, обратный вызов) {
		return jQuery.get(url, undefined, обратный вызов, «скрипт»);
	}
});

jQuery.each([ "получить", "опубликовать"], function( _i, метод) {
	jQuery[метод] = функция(url, данные, обратный вызов, тип) {

		// Сдвиг аргументов, если аргумент данных был опущен
		если ( isFunction ( данные ) ) {
			тип = тип || перезвонить;
			обратный вызов = данные;
			данные = не определены;
		}

		// URL-адрес может быть объектом параметров (который тогда должен иметь расширение .url)
		вернуть jQuery.ajax( jQuery.extend( {
			URL: URL,
			тип: метод,
			тип данных: тип,
			данные: данные,
			успех: обратный вызов
		}, jQuery.isPlainObject(url) && url));
	};
});

jQuery.ajaxPrefilter(функция(s) {
	вар я;
	for (я в s.headers) {
		if ( i.toLowerCase() === "тип содержимого") {
			s.contentType = s.headers[ я ] || "";
		}
	}
});


jQuery._evalUrl = функция (url, параметры, документ) {
	вернуть jQuery.ajax( {
		URL: URL,

		// Сделайте это явным образом, поскольку пользователь может переопределить это через ajaxSetup (trac-11264)
		тип: «ПОЛУЧИТЬ»,
		тип данных: «скрипт»,
		кеш: правда,
		асинхронный: ложь,
		глобально: ложь,

		// Оцениваем ответ только в том случае, если он успешен (gh-4126)
		// dataFilter не вызывается для ответов об ошибке, поэтому вместо этого используем его
		// конвертер по умолчанию неуклюж, но работает.
		конвертеры: {
			"текстовый скрипт": function() {}
		},
		Фильтр данных: функция (ответ) {
			jQuery.globalEval(ответ, параметры, документ);
		}
	});
};


jQuery.fn.extend( {
	оберткаВсе: функция (html) {
		вар-обертка;

		если ( это [ 0 ] ) {
			если ( isFunction( html ) ) {
				html = html.call(это[0]);
			}

			// Элементы, вокруг которых нужно обернуть цель
			обертка = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

			если ( это [ 0 ].parentNode ) {
				Wrap.insertBefore(это [0]);
			}

			Wrap.map(функция() {
				вар элем = это;

				в то время как (elem.firstElementChild) {
					элемент = элемент.firstElementChild;
				}

				вернуть элемент;
			} ).append( это);
		}

		верните это;
	},

	оберткаInner: функция (html) {
		если ( isFunction( html ) ) {
			верните this.each( function( i ) {
				jQuery(this).wrapInner(html.call(this, i));
			});
		}

		верните this.each( function() {
			вар self = jQuery(это),
				содержимое = self.contents();

			если (content.length) {
				содержимое.wrapAll(html);

			} еще {
				self.append(html);
			}
		});
	},

	обертка: функция (html) {
		вар htmlIsFunction = isFunction(html);

		верните this.each( function( i ) {
			jQuery(this).wrapAll(htmlIsFunction? html.call(this, i): html);
		});
	},

	развернуть: функция (селектор) {
		this.parent( селектор ).not( "тело") ).each( function() {
			jQuery(this).replaceWith(this.childNodes);
		});
		верните это;
	}
});


jQuery.expr.pseudos.hidden = функция (элемент) {
	return !jQuery.expr.pseudos.visible(elem);
};
jQuery.expr.pseudos.visible = функция(элемент) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = функция() {
	пытаться {
		вернуть новое окно.XMLHttpRequest();
	} поймать ( е ) {}
};

вар xhrSuccessStatus = {

		// Файловый протокол всегда выдает код состояния 0, предположим, 200
		0:200,

		// Поддержка: только IE <=9
		// trac-1450: иногда IE возвращает 1223, хотя должно быть 204
		1223:204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && («withCredentials» в xhrSupported);
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(функция(опции) {
	обратный вызов вар, errorCallback;

	// Междоменный доступ разрешен только в том случае, если поддерживается через XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		возвращаться {
			отправить: функция (заголовки, завершено) {
				вар я,
					xhr = options.xhr();

				xhr.open(
					параметры.тип,
					варианты.url,
					параметры.асинхронный,
					параметры.имя пользователя,
					параметры.пароль
				);

				// Применяем пользовательские поля, если они предусмотрены
				если (options.xhrFields) {
					for (я в options.xhrFields) {
						xhr[i] = options.xhrFields[i];
					}
				}

				// При необходимости переопределить тип mime
				если ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// Заголовок X-Requested-With
				// Для междоменных запросов, поскольку условия предполетной проверки
				// это похоже на пазл, мы просто никогда не собираем его, чтобы быть уверенным.
				// (его всегда можно установить для каждого запроса или даже с помощью ajaxSetup)
				// Для запросов того же домена заголовок не будет изменен, если он уже указан.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With"] = "XMLHttpRequest";
				}

				// Устанавливаем заголовки
				for (я в заголовках) {
					xhr.setRequestHeader(я, заголовки[я]);
				}

				// Перезвонить
				обратный вызов = функция (тип) {
					функция возврата() {
						если (обратный вызов) {
							обратный вызов = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = ноль;

							if (тип === "прервать") {
								xhr.abort();
							} else if (type === "ошибка") {

								// Поддержка: только IE <=9
								// При ручном прерывании IE9 выдает
								// ошибки при любом доступе к свойству, отличному от ReadyState
								if ( typeof xhr.status !== "number" ) {
									завершено (0, «ошибка»);
								} еще {
									полный(

										// Файл: протокол всегда возвращает статус 0; см. trac-8605, trac-14207
										xhr.статус,
										xhr.statusText
									);
								}
							} еще {
								полный(
									xhrSuccessStatus[ xhr.status ] || xhr.статус,
									xhr.statusText,

									// Поддержка: только IE <=9
									// IE9 не имеет XHR2, но выдает двоичный код (trac-11426)
									// Для нетекстового XHR2 позвольте вызывающему объекту обработать его (gh-2498)
									( xhr.responseType || "текст" ) !== "текст" ||
									typeof xhr.responseText !== "строка" ?
										{двоичный: xhr.response}:
										{ текст: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Слушаем события
				xhr.onload = обратный вызов();
				errorCallback = xhr.onerror = xhr.ontimeout = обратный вызов («ошибка»);

				// Поддержка: только IE 9
				// Используйте onreadystatechange для замены onabort
				// для обработки неперехваченных прерываний
				if ( xhr.onabort !== не определено ) {
					xhr.onabort = errorCallback;
				} еще {
					xhr.onreadystatechange = функция() {

						// Проверяем ReadyState перед таймаутом при его изменении
						если ( xhr.readyState === 4 ) {

							// Разрешить вызов onerror первым,
							// но это не обработает встроенное прерывание
							// Также сохраняем errorCallback в переменную
							// поскольку доступ к xhr.onerror недоступен
							window.setTimeout(функция() {
								если (обратный вызов) {
									ошибкаОбратный вызов();
								}
							});
						}
					};
				}

				// Создаем обратный вызов прерывания
				обратный вызов = обратный вызов («прервать»);

				пытаться {

					// Отправляем запрос (это может вызвать исключение)
					xhr.send( options.hasContent && options.data || null );
				} поймать ( е ) {

					// trac-14683: повторно генерировать только в том случае, если об этом еще не было уведомлено как об ошибке
					если (обратный вызов) {
						бросить е;
					}
				}
			},

			прерывание: функция() {
				если (обратный вызов) {
					перезвонить();
				}
			}
		};
	}
});




// Предотвращаем автоматическое выполнение скриптов, если не указан явный тип данных (см. gh-2432)
jQuery.ajaxPrefilter(функция(s) {
	если ( s.crossDomain ) {
		s.contents.script = ложь;
	}
});

// Устанавливаем тип данных скрипта
jQuery.ajaxSetup( {
	принимает: {
		скрипт: "текст/javascript, приложение/javascript, " +
			"приложение/ecmascript, приложение/x-ecmascript"
	},
	содержание: {
		скрипт: /\b(?:java|ecma)script\b/
	},
	конвертеры: {
		"текстовый скрипт": функция(текст) {
			jQuery.globalEval(текст);
			вернуть текст;
		}
	}
});

// Обработка особого случая кэша и перекрестного домена
jQuery.ajaxPrefilter("скрипт", функция(s) {
	если ( s.cache === не определено ) {
		с.кэш = ложь;
	}
	если ( s.crossDomain ) {
		s.type = "ПОЛУЧИТЬ";
	}
});

// Привязка тега скрипта для взлома транспорта
jQuery.ajaxTransport("скрипт", функция(s) {

	// Этот транспорт обрабатывает только междоменные или форсированные запросы attr.
	если ( s.crossDomain || s.scriptAttrs ) {
		вар-скрипт, обратный вызов;
		возвращаться {
			отправить: функция( _, завершено) {
				скрипт = jQuery("<скрипт>" )
					.attr( s.scriptAttrs || {} )
					.prop( {кодировка: s.scriptCharset, источник: s.url })
					.on("ошибка загрузки", обратный вызов = функция(evt) {
						скрипт.удалить();
						обратный вызов = ноль;
						если (эвт) {
							Complete (evt.type === «ошибка»? 404: 200, evt.type);
						}
					});

				// Используйте встроенные манипуляции с DOM, чтобы избежать мошенничества с AJAX domManip
				document.head.appendChild(скрипт[0]);
			},
			прерывание: функция() {
				если (обратный вызов) {
					перезвонить();
				}
			}
		};
	}
});




вар oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Настройки jsonp по умолчанию
jQuery.ajaxSetup( {
	jsonp: "обратный вызов",
	jsonpCallback: функция() {
		вар обратный вызов = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		это[обратный вызов] = правда;
		обратный вызов;
	}
});

// Обнаружение, нормализация параметров и установка обратных вызовов для запросов jsonp
jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

	var callbackName, перезаписан, responseContainer,
		jsonProp = s.jsonp !== false && (rjsonp.test(s.url)?
			"адрес":
			typeof s.data === "строка" &&
				( s.contentType || "" )
					.indexOf("application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test(s.data) && "данные"
		);

	// Обработка, если ожидаемый тип данных — «jsonp» или у нас есть параметр для установки
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Получаем имя обратного вызова, запоминая ранее существовавшее значение, связанное с ним
		callbackName = s.jsonpCallback = isFunction(s.jsonpCallback)?
			s.jsonpCallback():
			с.jsonpCallback;

		// Вставляем обратный вызов в URL или данные формы
		если ( jsonProp ) {
			s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Используем конвертер данных для получения json после выполнения скрипта
		s.converters[ "script json" ] = function() {
			если (!responseContainer) {
				jQuery.error(callbackName + "не был вызван");
			}
			вернуть ответКонтейнер[0];
		};

		// Форсируем тип данных json
		s.dataTypes[0] = "json";

		// Устанавливаем обратный вызов
		перезаписано = окно [имя обратного вызова];
		окно[имя обратного вызова] = функция() {
			ответКонтейнер = аргументы;
		};

		// Функция очистки (срабатывает после конвертеров)
		jqXHR.always(функция() {

			// Если предыдущее значение не существовало - удаляем его
			если (перезаписано === неопределенно) {
				jQuery(окно).removeProp(имя обратного вызова);

			// В противном случае восстанавливаем ранее существовавшее значение
			} еще {
				окно [имя обратного вызова] = перезаписано;
			}

			// Сохраняем обратно как бесплатное
			если ( s [имя обратного вызова ] ) {

				// Убедитесь, что повторное использование параметров не испортит ситуацию
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Сохраняем имя обратного вызова для использования в будущем
				oldCallbacks.push(имя обратного вызова);
			}

			// Вызов, если это была функция и у нас есть ответ
			if (responseContainer && isFunction(перезаписано)) {
				перезаписан(responseContainer[0]);
			}

			responseContainer = перезаписан = не определено;
		});

		// Делегируем скрипту
		вернуть «скрипт»;
	}
});




// Поддержка: только Safari 8
// В Safari 8 документы, созданные с помощью document.implementation.createHTMLDocument
// сворачиваем родственные формы: вторая становится дочерней по отношению к первой.
// По этой причине эту меру безопасности необходимо отключить в Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Аргумент «данные» должен быть строкой HTML
// контекст (необязательно): если указано, фрагмент будет создан в этом контексте,
// по умолчанию документ
// KeepScripts (необязательно): если true, будут включены скрипты, переданные в строке html.
jQuery.parseHTML = функция (данные, контекст, KeepScripts) {
	if ( typeof data !== "строка" ) {
		возвращаться [];
	}
	if ( typeof context === "boolean" ) {
		KeepScripts = контекст;
		контекст = ложь;
	}

	база var, анализируемая, скрипты;

	если ( !контекст ) {

		// Немедленное выполнение сценариев или встроенных обработчиков событий
		// с помощью document.implementation
		если (support.createHTMLDocument) {
			контекст = document.implementation.createHTMLDocument( "" );

			// Устанавливаем базовую ссылку для созданного документа
			// поэтому любые проанализированные элементы с URL-адресами
			// основаны на URL-адресе документа (gh-2965)
			base = context.createElement("база");
			base.href = document.location.href;
			context.head.appendChild(база);
		} еще {
			контекст = документ;
		}
	}

	анализируется = rsingleTag.exec(данные);
	скрипты = !keepScripts && [];

	// Один тег
	если (проанализировано) {
		return [context.createElement(parsed[1])];
	}

	анализируемый = buildFragment([данные], контекст, скрипты);

	if (скрипты && scripts.length) {
		jQuery(скрипты).remove();
	}

	return jQuery.merge( [], parsed.childNodes);
};


/**
 * Загрузите URL-адрес на страницу
 */
jQuery.fn.load = функция (url, параметры, обратный вызов) {
	селектор var, тип, ответ,
		я = это,
		выкл = url.indexOf( " " );

	если (выкл. > -1) {
		селектор = StripAndCollapse(url.slice(off));
		URL = url.slice(0, выкл);
	}

	// Если это функция
	если ( isFunction ( параметры ) ) {

		// Мы предполагаем, что это обратный вызов
		обратный вызов = параметры;
		параметры = не определено;

	// В противном случае создадим строку параметров
	} else if ( params && typeof params === "object") {
		тип = "ПОСТ";
	}

	// Если у нас есть элементы для изменения, делаем запрос
	если ( собственная длина > 0 ) {
		jQuery.ajax( {
			URL: URL,

			// Если переменная "type" не определена, то будет использован метод "GET".
			// Сделайте значение этого поля явным, поскольку
			// пользователь может переопределить его с помощью метода ajaxSetup
			тип: тип || "ПОЛУЧАТЬ",
			Тип данных: «html»,
			данные: параметры
		} ).done( функция(ResponseText) {

			// Сохраняем ответ для использования в полном обратном вызове
			ответ = аргументы;

			self.html(селектор?

				// Если был указан селектор, найдите нужные элементы в фиктивном div
				// Исключаем сценарии, чтобы избежать ошибок IE «Отказано в разрешении»
				jQuery( "<div>" ).append( jQuery.parseHTML(ResponseText)).find(селектор):

				// В противном случае используем полный результат
				Текст ответа);

		// Если запрос успешен, эта функция получает «данные», «статус», «jqXHR»
		// но они игнорируются, поскольку ответ был установлен выше.
		// В случае неудачи эта функция получает "jqXHR", "статус", "ошибку"
		} ).always( обратный вызов && function( jqXHR, status ) {
			self.each( функция() {
				callback.apply( this, ответ || [ jqXHR.responseText, status, jqXHR ] );
			});
		});
	}

	верните это;
};




jQuery.expr.pseudos.animated = функция(элемент) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		вернуть элемент === fn.elem;
	} ).длина;
};




jQuery.offset = {
	setOffset: function(elem, options, i) {
		вар curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, CalculPosition,
			позиция = jQuery.css(элемент, "позиция"),
			curElem = jQuery(элемент),
			реквизит = {};

		// Сначала устанавливаем позицию, в случае, если верхний/левый установлены даже на статическом элементе
		if (позиция === "статический") {
			elem.style.position = "относительный";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css(elem, "top");
		curCSSLeft = jQuery.css(elem, "left");
		CalculatePosition = ( позиция === "абсолютная" || позиция === "фиксированная") &&
			(curCSSTop + curCSSLeft).indexOf("авто") > -1;

		// Необходимо иметь возможность вычислять позицию, если
		// верх или лево — автоматически, а позиция — абсолютная или фиксированная
		если (вычислитьПозицию) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} еще {
			curTop = parseFloat(curCSSTop) || 0;
			curLeft = parseFloat(curCSSLeft) || 0;
		}

		если ( isFunction (опции ) ) {

			// Используйте здесь jQuery.extend, чтобы разрешить изменение аргумента координат (gh-1848)
			options = options.call(elem, i, jQuery.extend({}, curOffset));
		}

		если ( options.top != ноль ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		если ( options.left != ноль ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if («использование» в опциях) {
			options.using.call(элемент, реквизит);

		} еще {
			curElem.css(реквизит);
		}
	}
};

jQuery.fn.extend( {

	// offset() связывает границу элемента с источником документа
	смещение: функция (опции) {

		// Сохраняем цепочку для сеттера
		если (аргументы.длина) {
			параметры возврата === не определены?
				этот :
				this.each( функция( я ) {
					jQuery.offset.setOffset(this, options, i);
				});
		}

		вар прямой, победа,
			элем = это [0];

		если ( !elem ) {
			возвращаться;
		}

		// Возвращаем нули для отключенных и скрытых (display: none) элементов (gh-2310)
		// Поддержка: только IE <= 11
		// Запускаем getBoundingClientRect для
		// отключенный узел в IE выдает ошибку
		если ( !elem.getClientRects().length ) {
			возврат {верх: 0, слева: 0};
		}

		// Получить позицию относительно документа, добавив прокрутку области просмотра к gBCR относительно области просмотра
		rect = elem.getBoundingClientRect();
		выигрыш = элемент.ownerDocument.defaultView;
		возвращаться {
			сверху: rect.top + win.pageYOffset,
			слева: rect.left + win.pageXOffset
		};
	},

	// Position() связывает поле поля элемента с полем заполнения его смещенного родителя
	// Это соответствует поведению абсолютного позиционирования CSS
	позиция: функция() {
		если ( !это[ 0 ] ) {
			возвращаться;
		}

		вар offsetParent, смещение, документ,
			элем = это[ 0 ],
			ParentOffset = {сверху: 0, слева: 0};

		// позиция: фиксированные элементы смещены относительно области просмотра, которая сама всегда имеет нулевое смещение
		if ( jQuery.css(elem, "position" ) === "fixed" ) {

			// Предположим, что позиция: фиксированная подразумевает наличие getBoundingClientRect
			смещение = elem.getBoundingClientRect();

		} еще {
			смещение = this.offset();

			// Учитываем *реальный* родительский элемент смещения, который может быть документом или его корневым элементом
			// когда идентифицирован статически позиционированный элемент
			документ = элемент.владелецДокумент;
			offsetParent = elem.offsetParent || документ.Элементдокумента;
			в то время как ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Включить границы в его смещение, поскольку они находятся за пределами источника его содержимого
				ParentOffset = jQuery( offsetParent ).offset();
				ParentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true);
				ParentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true);
			}
		}

		// Вычитаем родительские смещения и поля элемента
		возвращаться {
			верх: offset.top - родительскийOffset.top - jQuery.css(elem, "marginTop", true),
			слева: offset.left -parentOffset.left - jQuery.css(elem, "marginLeft", true)
		};
	},

	// Этот метод вернет documentElement в следующих случаях:
	// 1) Для элемента внутри iframe без offsetParent этот метод вернет
	// documentElement родительского окна
	// 2) Для скрытого или отдельного элемента
	// 3) Для тела или элемента html, т.е. в случае узла html - он вернет сам себя
	//
	// но эти исключения никогда не были представлены как реальные варианты использования
	// и может рассматриваться как более предпочтительный результат.
	//
	// Однако эта логика не гарантирована и может измениться в любой момент в будущем
	offsetParent: function() {
		верните this.map( function() {
			вар offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			вернуть offsetParent || ДокументЭлемент;
		});
	}
});

// Создаем методы ScrollLeft и ScrollTop
jQuery.each( {scrollLeft: "pageXOffset", ScrollTop: "pageYOffset" }, function(method, prop) {
	вар топ = "pageYOffset" === опора;

	jQuery.fn[метод] = функция(значение) {
		возврат доступа (это, функция (элемент, метод, значение) {

			// Объединяем документы и окна
			вар победа;
			если ( isWindow( элем ) ) {
				победа = элемент;
			} Еще если (elem.nodeType === 9) {
				победа = элемент.defaultView;
			}

			если (значение === неопределенное) {
				вернуть победу? win[prop]: elem[метод];
			}

			если (выиграть) {
				win.scrollTo(
					!вершина ? значение: win.pageXOffset,
					вершина ? значение: win.pageYOffset
				);

			} еще {
				элемент [метод] = значение;
			}
		}, метод, значение, аргументы.длина);
	};
});

// Поддержка: Safari <=7–9.1, Chrome <=37–49
// Добавляем верхний/левый cssHook с помощью jQuery.fn.position
// Ошибка Webkit: https://bugs.webkit.org/show_bug.cgi?id=29084
// Ошибка мигания: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle возвращает проценты, если указано сверху/слева/снизу/справа;
// вместо того, чтобы заставлять модуль CSS зависеть от модуля смещения, просто проверьте его здесь
jQuery.each([ "сверху", "слева"], function( _i, prop ) {
	jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
		функция( элем, вычислено ) {
			если (вычислено) {
				вычисленный = curCSS (элемент, опора);

				// Если curCSS возвращает процент, возвращается к смещению
				вернуть rnumnonpx.test(вычислено)?
					jQuery(elem).position()[prop] + "px":
					вычислено;
			}
		}
	);
});


// Создаём методы InternalHeight, InternalWidth, Height, Width, OuterHeight и OuterWidth.
jQuery.each( { Высота: "высота", Ширина: "ширина" }, функция( имя, тип ) {
	jQuery.each( {
		отступ: «внутренний» + имя,
		Тип содержимого,
		"": "внешний" + имя
	}, функция (defaultExtra, funcName) {

		// Поле предназначено только для externalHeight, externalWidth
		jQuery.fn[ funcName ] = функция (поля, значение) {
			var Chainable = аргументы.длина && (defaultExtra || typeof поля !== "boolean" ),
				дополнительно = по умолчаниюДополнительно || (маржа === true || значение === true ? «маржа»: «граница»);

			возврат доступа (это, функция (элемент, тип, значение) {
				вар док;

				если ( isWindow( элем ) ) {

					// $( window ).outerWidth/Height возвращает значение, включая полосы прокрутки (gh-1729)
					return funcName.indexOf("outer") === 0?
						элем["внутренний" + имя]:
						elem.document.documentElement["клиент" + имя];
				}

				// Получаем ширину или высоту документа
				если ( elem.nodeType === 9 ) {
					документ = элемент.DocumentElement;

					// Либо прокрутка[Ширина/Высота], либо смещение[Ширина/Высота], либо клиент[Ширина/Высота],
					// смотря что больше
					вернуть Math.max(
						elem.body[ "прокрутка" + имя ], doc[ "прокрутка" + имя ],
						elem.body[ "смещение" + имя], doc[ "смещение" + имя],
						документ["клиент" + имя]
					);
				}

				возвращаемое значение === неопределенное?

					// Получаем ширину или высоту элемента, запрашивая, но не заставляя parseFloat
					jQuery.css(элемент, тип, дополнительно):

					// Устанавливаем ширину или высоту элемента
					jQuery.style(элемент, тип, значение, дополнительно);
			}, тип, цепной ? маржа: неопределенная, цепочка);
		};
	});
});


jQuery.each( [
	"аяксстарт",
	"аяксстоп",
	"ajaxComplete",
	"аяксОшибка",
	"ajaxУспех",
	"аяксОтправить"
], функция( _i, тип ) {
	jQuery.fn[тип] = функция(fn) {
		вернуть this.on(тип, fn);
	};
});




jQuery.fn.extend( {

	привязка: функция (типы, данные, fn) {
		return this.on(types, null, data, fn);
	},
	отменить привязку: функция (типы, fn) {
		вернуть this.off(types, null, fn);
	},

	делегат: функция (селектор, типы, данные, fn) {
		return this.on(types, selector, data, fn);
	},
	неделегировать: функция (селектор, типы, fn) {

		// (пространство имен) или (селектор, типы [, fn])
		вернуть аргументы.длина === 1?
			this.off(селектор, "**"):
			this.off( типы, селектор || "**", fn );
	},

	наведение: функция (fnOver, fnOut) {
		верните это
			.on("mouseenter", fnOver)
			.on( "mouseleave", fnOut || fnOver);
	}
});

jQuery.each(
	( "размытие фокуса фокусировка изменение размера прокрутка щелчок dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	«изменить, выбрать, отправить, нажать клавишу, нажать клавишу, контекстное меню». ).split( " " ),
	функция( _i, имя) {

		// Обработка привязки события
		jQuery.fn[имя] = функция(данные, fn) {
			вернуть аргументы.длина > 0?
				this.on(имя, ноль, данные, fn):
				this.trigger(имя);
		};
	}
);




// Поддержка: только Android <= 4.0
// Убедитесь, что мы обрезаем спецификацию и NBSP
// Требовать, чтобы «прогон с пробелами» начинался с непробельного пробела
// чтобы избежать поведения O(N^2), когда движок пытается сопоставить "\s+$" в каждой позиции пробела.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Привязываем функцию к контексту, при необходимости частично применяя любой
// аргументы.
// jQuery.proxy устарел для продвижения стандартов (в частности, Function#bind)
// Однако в ближайшее время его удалять не планируется
jQuery.proxy = функция (fn, контекст) {
	вар tmp, аргументы, прокси;

	if ( typeof context === "строка" ) {
		tmp = fn[контекст];
		контекст = ФН;
		фн = ТМП;
	}

	// Быстрая проверка, чтобы определить, можно ли вызвать цель, в спецификации
	// это выдает ошибку TypeError, но мы просто вернем неопределенное значение.
	если ( !isFunction( fn ) ) {
		вернуть неопределенное значение;
	}

	// Имитация привязки
	args = срез.вызов(аргументы, 2);
	прокси = функция() {
		return fn.apply( context || this, args.concat( срез.call(аргументы ) ) );
	};

	// Устанавливаем идентификатор уникального обработчика таким же, как у исходного обработчика, чтобы его можно было удалить
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	возврат прокси;
};

jQuery.holdReady = функция (удерживать) {
	если (удерживать) {
		jQuery.readyWait++;
	} еще {
		jQuery.ready(истина);
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = имя узла;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = CamelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = функция(объект) {

	// Начиная с jQuery 3.0, isNumeric ограничен
	// строки и числа (примитивы или объекты)
	// которые можно привести к конечным числам (gh-2662)
	тип вар = jQuery.type(obj);
	return (тип === "число" || тип === "строка" ) &&

		// parseFloat NaNs с числовым преобразованием ложных срабатываний ("")
		// ...но неправильно интерпретирует строки с начальными числами, особенно шестнадцатеричные литералы ("0x...")
		// вычитание приводит бесконечность к NaN
		!isNaN(obj - parseFloat(obj));
};

jQuery.trim = функция(текст) {
	возвращаемый текст == ноль?
		"" :
		(текст + "").replace(rtrim, "$1");
};



// Зарегистрируйтесь как именованный модуль AMD, поскольку jQuery можно объединить с другими
// файлы, которые могут использовать define, но не через соответствующий скрипт конкатенации, который
// понимает анонимные модули AMD. Именованный AMD является самым безопасным и надежным
// способ регистрации. Используется строчный jquery, поскольку имена модулей AMD
// получено из имен файлов, а jQuery обычно доставляется в нижнем регистре
// имя файла. Сделайте это после создания глобального, чтобы, если модуль AMD захочет
// вызвать noConflict, чтобы скрыть эту версию jQuery, это сработает.

// Обратите внимание, что для максимальной переносимости библиотеки, отличные от jQuery, должны
// объявляем себя анонимными модулями и избегаем установки глобального значения, если
// Загрузчик AMD присутствует. jQuery — особый случай. Для получения дополнительной информации см.
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		вернуть jQuery;
	});
}




вар

	// Сопоставление с jQuery в случае перезаписи
	_jQuery = окно.jQuery,

	// Сопоставление $ в случае перезаписи
	_$ = окно.$;

jQuery.noConflict = функция (глубокая) {
	если ( window.$ === jQuery ) {
		окно.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		окно.jQuery = _jQuery;
	}

	вернуть jQuery;
};

// Предоставляем идентификаторы jQuery и $, даже в AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// и CommonJS для эмуляторов браузера (trac-13566)
if ( typeof noGlobal === "не определено" ) {
	window.jQuery = window.$ = jQuery;
}




вернуть jQuery;
});